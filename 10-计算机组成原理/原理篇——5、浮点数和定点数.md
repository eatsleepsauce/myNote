#### 浮点数和定点数

##### 一、定点数

以32位为例，4个比特可以表示0-9的整数，32位就可以表示8个这样的整数，我们可以把最右边的2个 0-9的整数当成小数部分，把左边6个 0-9的整数，当成整数部分。这样32个比特就可以表示从0 到 999999.99这样的数了。

这种用二进制表示十进制的编码方式，叫做 **BCD编码**（Binary-Coded Decimal）。最常用的是在超市、银行这样需要用小数纪录金额的情况里。

**缺点：**

（1）这样的表示方式有点儿“浪费”，32个比特可以表示40亿个不同的数字，但是这种编码只能表示1个亿的数。

（2）没法同时表示很大的数字和很小的数字。

##### 二、浮点数

在现实中我们会用科学计数法表示一个数字，1 × 10的几次方，在计算机里面，可以用一样的方法，浮点数的科学计数法表示，有一个IEEE的标准，它定义了两种基本格式，一个是用32比特表示单精度的浮点数，也就是我们常说的float。另外一个使用64比特表示双精度的浮点数，也就是double。

单精度的32个比特分为三个部分：

<img src="https://liuyang-picbed.oss-cn-shanghai.aliyuncs.com/img/914b71bf1d85fb6ed76e1135f39b6941.jpg" alt="914b71bf1d85fb6ed76e1135f39b6941" style="zoom:25%;" />

第一部分 符号位，第二部分 指数位，第三部分 有效数位(有效位第一个默认1 所以可以节省1个比特)。

浮点数的计算公式：

![屏幕快照 2020-12-27 下午10.36.05](https://liuyang-picbed.oss-cn-shanghai.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202020-12-27%20%E4%B8%8B%E5%8D%8810.36.05.png)

需要注意：

e表示从-126到127个，所以用中间127表示0，如果是是-1次方，就用126表示。e的0和255有特殊用处，其中用来表示数字0就是一个特殊用处，还有其它表示无穷大、无穷小、NAN。（正常用上面公式没法表示0。而1的表示就是 0011111110000000000000000000000）

<img src="https://liuyang-picbed.oss-cn-shanghai.aliyuncs.com/img/f922249a89667c4d10239eb8840dc94c.jpg" alt="f922249a89667c4d10239eb8840dc94c" style="zoom:25%;" />

##### 三、浮点数精度问题

###### 1、浮点数的的二进制转化

在二进制里面，变成一个“符号位 s+ 指数位 e+ 有效位数 f”的组合。

我们要做的，就是把这个数变成二进制。整数部分变成二进制的方法直接使用短除法，而小数部分是用一个相似的方向操作，就是乘以2，然后看是否超过1，如果超过1，我们就记下1，并把结果减去1，进一步循环操作。

以9.1为例，整数部分就是1001，而小数部分：

<img src="https://liuyang-picbed.oss-cn-shanghai.aliyuncs.com/img/f9213c43f5fa658a2192a68cd26435ae.jpg" alt="f9213c43f5fa658a2192a68cd26435ae" style="zoom:25%;" />

0.1变成了一个无限循环的二进制小数，0.000110011，0011会无限循环下去。9.1就变成了1001.000110011...。科学计数法就变成了：

1.001000110011... × 2的三次方

<img src="https://liuyang-picbed.oss-cn-shanghai.aliyuncs.com/img/9ace5a7404d1790b03d07bd1b3cb5a27.jpeg" alt="9ace5a7404d1790b03d07bd1b3cb5a27" style="zoom:25%;" />

**因为能够表示的有效位有限，所以浮点数会出现精度问题。**

###### 2、浮点数的加法

浮点数的加法原则是，**先对齐，再计算**。

实现这样一个加法，也只需要位移。和整数加法类似的半加器和全加器的方法就能够实现，在电路层面，也并没有引入太多新的复杂性。

0.5+0.125 为例：

<img src="https://liuyang-picbed.oss-cn-shanghai.aliyuncs.com/img/d7a6e87da9c0d0b874980ca4306a55f0.jpg" alt="d7a6e87da9c0d0b874980ca4306a55f0" style="zoom:25%;" />

指数较小的数，需要**有效位进行右移**，在右移的过程中，最右侧的有效位可能会丢失。这也是 **加法造成精度丢失的原因**。

32 位浮点数的有效位长度一共只有 23 位，如果两个数的指数位差出 23 位，较小的数右移 24 位之后，所有的有效位就都丢失了。这也就意味着，虽然浮点数可以表示上到 3.40×10的38次方，下到 1.17×10的−38次方 这样的数值范围。但是在实际计算的时候，只要两个数，差出 2的24次方，也就是差不多 1600 万倍，那这两个数相加之后，结果完全不会变化。

```
// 2000万的32位浮点数和1相加 +1 
public class FloatPrecision {
  public static void main(String[] args) {
    float a = 20000000.0f;
    float b = 1.0f;
    float c = a + b;
    System.out.println("c is " + c);
    float d = c - a;
    System.out.println("d is " + d);
  }
}
```

输出结果：

```
c is 2.0E7
d is 0.0
```





**Kahan Summation 算法：**

其实这个算法的原理其实并不复杂，就是在每次的计算过程中，都用一次减法，把当前加法计算中损失的精度记录下来，然后在后面的循环中，把这个精度损失放在要加的小数上，再做一次运算

想要更深入地了解乘法乃至除法，可以参看《计算机组成与设计 硬件 / 软件接口》的 3.5.2 和 3.5.3 小节。