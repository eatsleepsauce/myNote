#### 虚拟内存、TLB和内存保护

##### 一、虚拟内存

###### 1、虚拟内存

在我们日常使用的 Linux 或者 Windows 操作系统下，**程序并不能直接访问物理内存**。我们的内存需要被分成固定大小的页（Page），然后再 **通过虚拟内存地址（Virtual Address）到物理内存地址（Physical Address）的地址转换（Address Translation）**，才能到达实际存放数据的物理内存位置。而我们的程序看到的内存地址，都是虚拟内存地址。

<img src="https://liuyang-picbed.oss-cn-shanghai.aliyuncs.com/img/0cf2f08e1ceda473df71189334857cf0.png" alt="0cf2f08e1ceda473df71189334857cf0" style="zoom: 50%;" />



###### 2、虚拟内存地址转换——简单页表

把虚拟内存地址，映射到物理内存地址，最直观的办法，就是来建一张映射表。这个映射表，能够实现虚拟内存里面的页，到物理内存里面的页的一一映射。这个映射表就叫作 **页表（Page Table）**。

页表这个地址转换的办法，会把一个内存地址分成 **页号（Directory）**和 **偏移量（Offset）**两个部分。前面的高位，就是内存地址的页号。后面的低位，就是内存地址里面的偏移量。

做地址转换的页表，只需要保留虚拟内存地址的页号和物理内存地址的页号之间的映射关系就可以了。**同一个页里面的内存，在物理层面是连续的**。以一个页的大小是 4K 字节（4KB）为例，我们需要 20 位的高位，12 位的低位（32位）。

<img src="https://liuyang-picbed.oss-cn-shanghai.aliyuncs.com/img/07cd4c3344690055240f215404a286dd.jpeg" alt="07cd4c3344690055240f215404a286dd" style="zoom: 33%;" />

内存地址转换，其实就是这样三个步骤：

（1）把虚拟内存地址，切分成页号和偏移量的组合；

（2）从页表里面，查询出虚拟页号，对应的物理页号；

（3）直接拿物理页号，加上前面的偏移量，就得到了物理内存地址。

32 位的内存地址空间，页表一共需要记录 2^20 个到物理页号的映射关系。这个存储关系，就好比一个 2^20 大小的数组。一个页号是完整的 32 位的 4 字节（Byte），这样一个页表就需要 4MB 的空间。

<img src="https://liuyang-picbed.oss-cn-shanghai.aliyuncs.com/img/8190dc8a065b06786f26ece596a8e9c9.jpg" alt="8190dc8a065b06786f26ece596a8e9c9" style="zoom: 33%;" />

**缺点：浪费空间，**每一个进程，都有属于自己独立的虚拟内存地址空间。这也就意味着，每一个进程都需要这样一个页表。

###### 3、虚拟内存地址转换——多级页表

大部分进程所占用的内存是有限的，需要的页也自然是很有限的。我们只需要去存那些用到的页之间的映射关系就好了。

**多级页表（Multi-Level Page Table）**的解决方案，我们以一个 4 级的多级页表为例，来看一下。同样一个虚拟内存地址，偏移量的部分和上面简单页表一样不变，但是原先的页号部分，我们把它拆成四段，从高到低，分成 4 级到 1 级这样 4 个页表索引。

<img src="https://liuyang-picbed.oss-cn-shanghai.aliyuncs.com/img/614034116a840ef565feda078d73cb76.jpeg" alt="614034116a840ef565feda078d73cb76" style="zoom: 25%;" />

最后一层的 1 级页表里面的条目，对应的数据内容就是物理页号了。在拿到了物理页号之后，我们同样可以用“页号 + 偏移量”的方式，来获取最终的物理内存地址。

我们可能有很多张 1 级页表、2 级页表，乃至 3 级页表。但是，因为实际的虚拟内存空间通常是连续的，我们很可能只需要很少的 2 级页表，甚至只需要 1 张 3 级页表就够了。

**多级页表就像一个多叉树的数据结构**，所以我们常常称它为 **页表树（Page Table Tree）**。因为虚拟内存地址分布的连续性，树的第一层节点的指针，很多就是空的，也就不需要有对应的子树了。所谓不需要子树，其实就是不需要对应的 2 级、3 级的页表。找到最终的物理页号，就好像通过一个特定的访问路径，走到树最底层的叶子节点。

<img src="https://liuyang-picbed.oss-cn-shanghai.aliyuncs.com/img/5ba17a3ecf3f9ce4a65546de480fcc4e.jpeg" alt="5ba17a3ecf3f9ce4a65546de480fcc4e" style="zoom: 25%;" />

4 级的多级页表来看，每一级如果都用 5 个比特表示。那么每一张某 1 级的页表，只需要 2^5=32 个条目。如果每个条目还是 4 个字节，那么一共需要 128 个字节。而一个 1 级索引表，对应 32 个 4KB 的也就是 128KB 的大小。一个填满的 2 级索引表，对应的就是 32 个 1 级索引表，也就是 4MB 的大小。

一个进程如果占用了 8MB 的内存空间，分成了 2 个 4MB 的连续空间。那么，它一共需要 2 个独立的、填满的 2 级索引表，也就意味着 64 个 1 级索引表，2 个独立的 3 级索引表，1 个 4 级索引表。一共需要 69 个索引表，每个 128 字节，大概就是 9KB 的空间。比起 4MB 来说，只有差不多 1/500。

**缺点：多级页表虽然节约了我们的存储空间，却带来了时间上的开销**，所以它其实是一个“以时间换空间”的策略。

##### 二、加速地址转换：TLB

多级页表虽然节约了我们的存储空间，但是却带来了时间上的开销，变成了一个“以时间换空间”的策略。原本我们进行一次地址转换，只需要访问一次内存就能找到物理页号，算出物理内存地址。但是用了 4 级页表，我们就需要访问 4 次内存，才能找到物理页号。

>程序所需要使用的指令，都顺序存放在虚拟内存里面。我们执行的指令，也是一条条顺序执行下去的。也就是说，我们对于指令地址的访问，存在“空间局部性”和“时间局部性”，而需要访问的数据也是一样的。我们连续执行了 5 条指令。因为内存地址都是连续的，所以这 5 条指令通常都在同一个“虚拟页”里。

把之前的内存转换地址缓存下来，使得我们不需要反复去访问内存来进行内存地址转换。

<img src="https://liuyang-picbed.oss-cn-shanghai.aliyuncs.com/img/ef754d9b2c816acff1dad63875ffea27.jpeg" alt="ef754d9b2c816acff1dad63875ffea27" style="zoom: 33%;" />

计算机工程师们专门在 CPU 里放了一块缓存芯片。这块缓存芯片我们称之为 TLB，全称是 **地址变换高速缓冲（Translation-Lookaside Buffer）**。这块缓存存放了之前已经进行过地址转换的查询结果。这样，当同样的虚拟地址需要进行地址转换的时候，我们可以直接在 TLB 里面查询结果，而不需要多次访问内存来完成一次转换。

TLB 和CPU 的高速缓存类似，可以分成指令的 TLB 和数据的 TLB，也就是 ITLB 和 DTLB。同样的，我们也可以根据大小对它进行分级，变成 L1、L2 这样多层的 TLB。

还有一点和 CPU 里的高速缓存也是一样的，需要用脏标记这样的标记位，来实现“写回”这样缓存管理策略。

整个内存转换过程由硬件来执行。在 CPU 芯片里面，封装了 **内存管理单元（MMU，Memory Management Unit）芯片，用来完成地址转换**。和 TLB 的访问和交互，都是由这个 MMU 控制的。

<img src="https://liuyang-picbed.oss-cn-shanghai.aliyuncs.com/img/432050446f68569a37c7699cccda75d9.jpeg" alt="432050446f68569a37c7699cccda75d9" style="zoom:33%;" />

##### 三、内存保护

> 虽然我们现代的操作系统和 CPU，已经做了各种权限的管控。正常情况下，我们已经通过虚拟内存地址和物理内存地址的区分，隔离了各个进程。但是，无论是 CPU 这样的硬件，还是操作系统这样的软件，都太复杂了，难免还是会被黑客们找到各种各样的漏洞。

###### 1、可执行空间保护

**可执行空间保护（Executable Space Protection）**，这个机制是说，我们对于一个进程使用的内存，只把其中的指令部分设置成“可执行”的，对于其他部分，比如数据部分，不给予“可执行”的权限。因为无论是指令，还是数据，在我们的 CPU 看来，都是二进制的数据。我们直接把数据部分拿给 CPU，如果这些数据解码后，也能变成一条合理的指令，其实就是可执行的。

服务端执行SQL防止sql注入也是这种思想。

###### 2、地址空间布局随机化

**地址空间布局随机化（Address Space Layout Randomization），**原先我们一个进程的内存布局空间是固定的，所以任何第三方很容易就能知道指令在哪里，程序栈在哪里，数据在哪里，堆又在哪里。这个其实为想要搞破坏的人创造了很大的便利。而地址空间布局随机化这个机制，就是让这些区域的位置不再固定，在内存空间随机去分配这些进程里不同部分所在的内存空间地址，让破坏者猜不出来。猜不出来呢，自然就没法找到想要修改的内容的位置。如果只是随便做点修改，程序只会 crash 掉，而不会去执行计划之外的代码。

<img src="https://liuyang-picbed.oss-cn-shanghai.aliyuncs.com/img/dbda1bd1d43d6fa9d7b552ca57d223b9.jpeg" alt="dbda1bd1d43d6fa9d7b552ca57d223b9" style="zoom: 33%;" />









对于虚拟内存的知识点，再深入读一读《计算机组成与设计：硬件 / 软件接口》的第 5.7 章节。还不过瘾，可以进一步去读一读《What Every Programmer Should Know About Memory》的第 4 部分，也就是 Virtual Memory。

