#### 编译、链接和装载

##### 一、编译、链接和装载

C语言程序到可以在计算机上执行，由两个部分组成：

第一部分由**编译（compile）、汇编（assemble）以及链接（link）**三个阶段组成，在这三个阶段完成之后，我们就生成了一个可执行文件。汇编之后得到的不是一个可执行文件，而是目标文件，只有通过**连接器（linker）**把多个目标文件以及调用的各种函数库链接起来，才能得到一个可执行文件。

第二部分，通过**装载器（loader）**把可执行文件装载（load）到内存中，CPU从内存中读取指令和数据，来开始真正执行程序。

<img src="https://liuyang-picbed.oss-cn-shanghai.aliyuncs.com/img/997341ed0fa9018561c7120c19cfa2a7.jpg" alt="997341ed0fa9018561c7120c19cfa2a7" style="zoom: 33%;" />

##### 二、ELF格式和链接

程序最终是通过装载器变成指令和数据的，所以我们生成的可以执行代码并不仅仅是一条条指令。

可执行代码objdump出来的内容和目标代码dump出来的差不多，但是长了很多，linux下，可执行文件和目标文件所使用都是一种叫 ELF（executable and linkable file format）的文件格式，这里面不仅存放了编译成的汇编指令，还保存了很多别的数据。

<img src="https://liuyang-picbed.oss-cn-shanghai.aliyuncs.com/img/276a740d0eabf5f4be905fe7326d9fb3.jpg" alt="276a740d0eabf5f4be905fe7326d9fb3" style="zoom:33%;" />

ELF文件格式把各种信息，分成一个一个的section保存起来：

（1）**基本头文件（File Header）**，用来表示这个文件的基本属性，比如是否是可执行文件，对应的CPU、操作系统等。
（2）**代码段 .text section**，用来保存程序的代码和指令。
（3）**数据段 .data section**，用来保存程序里面设置好的初始化数据信息。
（4）**重定位表 .rel.text section**，重定位表里面保存的是当前的文件里面，哪些跳转地址是我们不知道的，比如调用了个printf或者自己写的add之类的函数，在链接发生之前，我们并不知道该跳转到那里。
（5）**符号表 .symtab section**，符号表保留了当前文件里面定义的函数名称和对应地址的地址簿。

**链接的主要流程：**

连接器会扫描所有输入的目标文件，然后把所有符号表里面的信息收集起来，构成一个全局的符号表。然后再根据重定位表，把所有不确定要跳转地址的代码，根据符号表里面存储的地址，进行一次修正。最后，把所有目标文件的对应段进行一次合并，变成了最终可以执行代码。

```
// add_lib.c
int add(int a, int b)
{
    return a+b;
}
```

```
// link_example.c
#include <stdio.h>
int main()
{
    int a = 10;
    int b = 5;
    int c = add(a, b);
    printf("c = %d\n", c);
}
```

生成目标文件，并查看汇编代码

```
$ gcc -g -c add_lib.c link_example.c
$ objdump -d -M intel -S add_lib.o
$ objdump -d -M intel -S link_example.o
```

链接生成可执行文件

```
$ gcc -o link-example add_lib.o link_example.o
$ ./link_example
c = 15
```

<img src="https://liuyang-picbed.oss-cn-shanghai.aliyuncs.com/img/f62da9b29aa53218f8907851df27f912.jpeg" alt="f62da9b29aa53218f8907851df27f912" style="zoom: 25%;" />

同样一个程序在linux下可以执行，而在windows下不醒，其中一个最主要的原因就是两个操作系统的可执行文件格式不一样，windows下的可执行文件是PE （Portable Executable Format）。如果我们有一个能够解析PE格式的装载器，我们就可以在linux下执行windows程序了，PS：linux开源项目Wine。同理windows也可以执行linux的程序，PS：WSL，windows subsystem for linux 可以解析和加载ELF格式文件。

##### 三、装载

在运行可执行文件的时候，是通过一个加载器，解析ELF或者PE格式的可执行文件，将对应的指令和数据加载到内存里面了来，让CPU去执行。

装载器需要满足两个要求：

（1）**可执行程序加载后占用的内存空间应该是连续的**。执行指令的时候，程序计数器是顺序一条一条指令执行下去的。

（2）**同时加载很多个程序，并且不能让程序自己规定在内存中加载的位置**。虽然编译出来的指令已经有了对应的各种各样的内存地址，但是实际加载的时候，其实没办法确保这个程序一定加载在那一段内存地址上。

**为了满足这个两个基本要求，我们可以在内存里面找到一段连续的内存空间，然后分配给装载程序，然后把这段连续的内存空间地址和整个程序指令里面指定的内存地址做一个映射。**

指令里面用到的内存地址叫做 **虚拟内存地址**（Virtual Memory Address），实际在内存硬件里面的空间地址，我们叫做 **物理内存地址**（Physical Memory Address）。（程序里有指令和各种内存地址，我们只需要关心虚拟内存地址就行了，对于任何一个程序来说，它看到的都是同样的内存地址。我们维护一个虚拟内存到物理内存到映射表，这样实际程序指令执行的时候，会通过虚拟内存地址找到对应的物理内存地址，然后执行，因为是连续的内存地址空间，所以只需要维护映射关系的起始地址和对应的空间大小。）

###### 1、内存分段

找出一段连续的物理内存和虚拟内存地址进行映射的方法，叫做 **分段**（Segmentation）。这里的段，是指系统分配出来的那个连续的内存空间。

<img src="https://liuyang-picbed.oss-cn-shanghai.aliyuncs.com/img/24596e1e66d88c5d077b4c957d0d7f18.png" alt="24596e1e66d88c5d077b4c957d0d7f18" style="zoom: 67%;" />

分段的方法解决了程序本身不需要关心具体的物理内存地址问题，但也有问题就是**内存碎片**（Memory Fragmentation）的问题。

<img src="https://liuyang-picbed.oss-cn-shanghai.aliyuncs.com/img/57211af3053ed621aeb903433c6c10d1.png" alt="57211af3053ed621aeb903433c6c10d1" style="zoom:67%;" />

内存碎片的问题可以通过 **内存交换**（Memory Swapping） 解决。我们可以把Python程序占用的256M内存写到硬盘上，然后再从硬盘上读回来到内存中，不过读回来的实际，我们不再把它加载到原来的位置，而是紧紧跟在已经被占了的512M内存后面，这样，我们就又有了连续的256M内存空，就可以加载新的程序了。在linux系统中，有个swap硬盘分区就是专门给linux操作系统进行内存交换用的。

###### 2、内存分页

**虚拟内存、分段，再加上内存交换**，看起来已经解决了计算机同时装载运行很多个程序的问题。但是这三者的组合仍然会遇到一个性能瓶颈——**硬盘的访问速度比内存慢很多**。而每次内存交换，我们都需要把一大段连续的内存数据写到硬盘上，整个机器都会显得卡顿。**并且无法运行大于物理内存的程序**。

解决上面问题的办法就是 **内存分页**（Paging），**和分段这样分配一整段连续的空间相比，分页是把整个物理内存空间切成一段段固定尺寸的大小**。而对应程序所需要占用的虚拟内存空间，也会同样切成一段段固定尺寸的大小。这样一个连续并且尺寸固定的内存空间，叫做 **页**（Page）。

从虚拟内存到物理内存的映射，不再是拿整段连续的物理内存地址，而是按一个一个页来。**页的尺寸一般远远小于整个程序的大小**。在linux下，通常默认页大小为4kb。

<img src="https://liuyang-picbed.oss-cn-shanghai.aliyuncs.com/img/0cf2f08e1ceda473df71189334857cf0.png" alt="0cf2f08e1ceda473df71189334857cf0" style="zoom:67%;" />

**内存分页**，在内存空间不够的时候通过 **内存交换释放出一些内存页** 来，一次性写入磁盘的也只是少数的页，不会花费太多的时间，这样机器就不会被内存交换给卡死。更近一步地，分页的方式使得加载程序的时候，**不需要一次性都把程序加载到物理内存中**，只是在程序运行中，需要用到对应的虚拟内存页里面的指令和数据时才加载到物理内存里面。

我们的操作系统就是这么干的，当读取特定的页，发现物理内存中没有的时候就会触发一个来自CPU的缺页错误，操作系统会捕捉到这个错误，然后将对应的页从磁盘里面读取出来加载到物理内存中。正是通过这种方式，使得我们可以运行比物理内存大得多的程序。

虚拟内存、内存交换和内存分页的组合，最终得到了一个让程序不需要考虑实际的物理内存地址、大小和当前分配空间的解决方案。

