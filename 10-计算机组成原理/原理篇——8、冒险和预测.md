#### 冒险和预测

##### 一、冒险

流水线设计需要解决的三大冒险，分别是 **结构冒险（Structural Hazard）、数据冒险（Data Hazard）以及控制冒险（Control Hazard）**。

###### 1、结构冒险

结构冒险，本质上是一个硬件层面的资源竞争问题，也就是一个硬件电路层面的问题。

5级流水线的示意图：

<img src="https://liuyang-picbed.oss-cn-shanghai.aliyuncs.com/img/c2a4c0340cb835350ea954cdc520704e.jpeg" alt="c2a4c0340cb835350ea954cdc520704e" style="zoom:33%;" />

在第 1 条指令执行到访存（MEM）阶段的时候，流水线里的第 4 条指令，在执行取指令（Fetch）的操作。访存和取指令，都要进行内存数据的读取。我们的内存，只有一个地址译码器的作为地址输入，那就只能在一个时钟周期里面读取一条数据，没办法同时执行第 1 条指令的读取内存数据和第 4 条指令的读取指令代码。

###### 2、结构冒险解决方案

（1）**增加资源**

**直观的解决方案就是把我们的内存分成两部分**，让它们各有各的地址译码器。这两部分分别是存放指令的程序内存和存放数据的数据内存。

现代的 CPU 虽然没有在内存层面进行对应的拆分，却在 CPU 内部的高速缓存部分进行了区分，把高速缓存分成了 **指令缓存（Instruction Cache）**和 **数据缓存（Data Cache）**两部分。内存的访问速度远比 CPU 的速度要慢，所以现代的 CPU 并不会直接读取主内存。它会从主内存把指令和数据加载到高速缓存中，这样后续的访问都是访问高速缓存。而指令缓存和数据缓存的拆分，使得我们的 CPU 在进行数据访问和取指令的时候，不会再发生资源冲突的问题了。

<img src="https://liuyang-picbed.oss-cn-shanghai.aliyuncs.com/img/e7508cb409d398380753b292b6df8391.jpeg" alt="e7508cb409d398380753b292b6df8391" style="zoom:33%;" />

（2）**NOP操作和指令对齐**

有些指令没有对应的流水线阶段，但是我们并不能跳过对应的阶段直接执行下一阶段。不然，如果我们先后执行一条 LOAD 指令和一条 ADD 指令，就会发生 LOAD 指令的 WB 阶段和 ADD 指令的 WB 阶段，在同一个时钟周期发生。这样，相当于触发了一个结构冒险事件，产生了资源竞争。

<img src="https://liuyang-picbed.oss-cn-shanghai.aliyuncs.com/img/b66ea9ca3300c7f71e91aaa6b6428fd4.jpg" alt="b66ea9ca3300c7f71e91aaa6b6428fd4" style="zoom:33%;" />

<img src="https://liuyang-picbed.oss-cn-shanghai.aliyuncs.com/img/9e62ab3b42e445d65accf0549badf45f.jpeg" alt="9e62ab3b42e445d65accf0549badf45f" style="zoom:33%;" />

所以，在实践当中，各个指令不需要的阶段，并不会直接跳过，而是会运行一次 NOP 操作。通过插入一个 NOP 操作，我们可以使后一条指令的每一个 Stage，一定不和前一条指令的同 Stage 在一个时钟周期执行。这样，就不会发生先后两个指令，在同一时钟周期竞争相同的资源，产生结构冒险了。

<img src="https://liuyang-picbed.oss-cn-shanghai.aliyuncs.com/img/c16643d83dd534d3d97d0d7ad8e30d42.jpg" alt="c16643d83dd534d3d97d0d7ad8e30d42" style="zoom:33%;" />

###### 3、数据冒险

数据冒险，其实就是同时在执行的多个指令之间，有数据依赖的情况。这些数据依赖，我们可以分成三大类，分别是 **先写后读（Read After Write，RAW）**、**先读后写（Write After Read，WAR）**和 **写后再写（Write After Write，WAW）**。

**（1）先写后读（Read After Write）**

```
int main() {
  int a = 1;
  int b = 2;
  a = b + a;
  b = a + b;
}

//汇编
int main() {
   0:   55                      push   rbp
   1:   48 89 e5                mov    rbp,rsp
  int a = 1;
   4:   c7 45 fc 01 00 00 00    mov    DWORD PTR [rbp-0x4],0x1
  int b = 2;
   b:   c7 45 f8 02 00 00 00    mov    DWORD PTR [rbp-0x8],0x2
  a = a + 2;
  12:   83 45 fc 02             add    DWORD PTR [rbp-0x4],0x2
  b = a + 3;
  16:   8b 45 fc                mov    eax,DWORD PTR [rbp-0x4]
  19:   83 c0 03                add    eax,0x3
  1c:   89 45 f8                mov    DWORD PTR [rbp-0x8],eax
}
  1f:   5d                      pop    rbp
  20:   c3                      ret        
```

我们需要保证，在内存地址为 16 的指令读取 rbp-0x4 里面的值之前，内存地址 12 的指令写入到 rbp-0x4 的操作必须完成。这就是先写后读所面临的数据依赖。如果这个顺序保证不了，我们的程序就会出错。这个先写后读的依赖关系，我们一般被称之为 **数据依赖**，也就是 Data Dependency。

**（2）先读后写（Write After Read）**

```
int main() {
  int a = 1;
  int b = 2;
  a = b + a;
  b = a + b;
}
//汇编
int main() {
   0:   55                      push   rbp
   1:   48 89 e5                mov    rbp,rsp
   int a = 1;
   4:   c7 45 fc 01 00 00 00    mov    DWORD PTR [rbp-0x4],0x1
   int b = 2;
   b:   c7 45 f8 02 00 00 00    mov    DWORD PTR [rbp-0x8],0x2
   a = b + a;
  12:   8b 45 f8                mov    eax,DWORD PTR [rbp-0x8]
  15:   01 45 fc                add    DWORD PTR [rbp-0x4],eax
   b = a + b;
  18:   8b 45 fc                mov    eax,DWORD PTR [rbp-0x4]
  1b:   01 45 f8                add    DWORD PTR [rbp-0x8],eax
}
  1e:   5d                      pop    rbp
  1f:   c3                      ret       
```

在内存地址为 15 的汇编指令里，我们要把 eax 寄存器里面的值读出来，再加到 rbp-0x4 的内存地址里。接着在内存地址为 18 的汇编指令里，我们要再写入更新 eax 寄存器里面。如果我们在内存地址 18 的 eax 的写入先完成了，在内存地址为 15 的代码里面取出 eax 才发生，我们的程序计算就会出错。这里，我们同样要保障对于 eax 的先读后写的操作顺序。这个先读后写的依赖，一般被叫作 **反依赖**，也就是 Anti-Dependency。 

**（3）写后再写（Write After Write）**

```
int main() {
  int a = 1;
  a = 2;
}
//汇编
int main() {
   0:   55                      push   rbp
   1:   48 89 e5                mov    rbp,rsp
  int a = 1;
   4:   c7 45 fc 01 00 00 00    mov    DWORD PTR [rbp-0x4],0x1
  a = 2;
   b:   c7 45 fc 02 00 00 00    mov    DWORD PTR [rbp-0x4],0x2
}
```

我们也需要保障内存地址 4 的指令的写入，在内存地址 b 的指令的写入之前完成。这个写后再写的依赖，一般被叫作 **输出依赖**，也就是 Output Dependency。

###### 4、数据冒险的解决方案

（1）**流水线停顿（Pipeline Stall）**，或者叫 **流水线冒泡（Pipeline Bubbling）**

水线停顿的办法很容易理解。如果我们发现了后面执行的指令，会对前面执行的指令有数据层面的依赖关系，那最简单的办法就是“再等等”。我们在进行指令译码的时候，会拿到对应指令所需要访问的寄存器和内存地址。所以，在这个时候，我们能够判断出来，这个指令是否会触发数据冒险。如果会触发数据冒险，我们就可以决定，让整个流水线停顿一个或者多个周期。其实，我们并没有办法真的停顿下来。流水线的每一个操作步骤必须要干点儿事情。所以，在实践过程中，我们并不是让流水线停下来，而是在执行后面的操作步骤前面，插入一个 NOP 操作，也就是执行一个其实什么都不干的操作。

<img src="https://liuyang-picbed.oss-cn-shanghai.aliyuncs.com/img/0d762f2ce532d87cfe69c7b167af9c2a.jpeg" alt="0d762f2ce532d87cfe69c7b167af9c2a" style="zoom:33%;" />

（2）**操作数前推**

```
add $t0, $s2,$s1
add $s2, $s1,$t0
//第一条指令，把 s1 和 s2 寄存器里面的数据相加，存入到 t0 这个寄存器里面。
//第二条指令，把 s1 和 t0 寄存器里面的数据相加，存入到 s2 这个寄存器里面。
```

因为后一条的 add 指令，依赖寄存器 t0 里的值。而 t0 里面的值，又来自于前一条指令的计算结果。所以后一条指令，需要等待前一条指令的数据写回阶段完成之后，才能执行。于是，我们就不得不通过流水线停顿来解决这个冒险问题。我们要在第二条指令的译码阶段之后，插入对应的 NOP 指令，直到前一天指令的数据写回完成之后，才能继续执行。这样的方案，也浪费了两个时钟周期。我们的第 2 条指令，其实就是多花了 2 个时钟周期，运行了两次空转的 NOP 操作。

<img src="https://liuyang-picbed.oss-cn-shanghai.aliyuncs.com/img/94dda2330b07c08530540ae11838c569.jpeg" alt="94dda2330b07c08530540ae11838c569" style="zoom:33%;" />

其实第二条指令的执行，未必要等待第一条指令写回完成，才能进行。我们完全可以在第一条指令的执行阶段完成之后，直接将结果数据传输给到下一条指令的 ALU。然后，下一条指令不需要再插入两个 NOP 阶段，就可以继续正常走到执行阶段。

<img src="https://liuyang-picbed.oss-cn-shanghai.aliyuncs.com/img/dceadd35c334974d8270052b37d48c27.jpeg" alt="dceadd35c334974d8270052b37d48c27" style="zoom:33%;" />

这样的解决方案，我们就叫作 **操作数前推**（Operand Forwarding），或者 **操作数旁路**（Operand Bypassing）。在 CPU 的硬件里面，需要再单独拉一根信号传输的线路出来，使得 ALU 的计算结果，能够重新回到 ALU 的输入里来。这样的一条线路，就是我们的“旁路”。它越过（Bypass）了写入寄存器，再从寄存器读出的过程，也为我们节省了 2 个时钟周期。

**操作数前推的解决方案不但可以单独使用，还可以和流水线冒泡一起使用**。有的时候，虽然我们可以把操作数转发到下一条指令，但是下一条指令仍然需要停顿一个时钟周期。

比如说，我们先去执行一条 LOAD 指令，再去执行 ADD 指令。LOAD 指令在访存阶段才能把数据读取出来，所以下一条指令的执行阶段，需要在访存阶段完成之后，才能进行。

<img src="https://liuyang-picbed.oss-cn-shanghai.aliyuncs.com/img/49f3a9b1ae2972ac5c6cfca7731bf12d.jpeg" alt="49f3a9b1ae2972ac5c6cfca7731bf12d" style="zoom:33%;" />



进一步理解流水线冒险里数据冒险的相关知识，你可以仔细看一看《计算机组成与设计：硬件 / 软件接口》的第 4.5～4.7 章。