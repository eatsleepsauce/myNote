#### 指令与运算

##### 一、计算机指令

从硬件的角度来看，CPU 就是一个超大规模集成电路，通过电路实现了加法、乘法乃至各种各样的处理逻辑。

从软件工程师的角度来讲，CPU就是一个执行各种计算机指令（Instruction Code）的逻辑机器。计算机指令就好比一门CPU能够听得懂的语言，即机器语言，不同的CPU能够听懂的语言不太一样，也就形成了不同的计算机指令集（Instructon Set）。

**从编译到汇编，代码变成机器码**，要让一个C语言程序在linux系统上跑起来，需要通过编译器把程序翻译成一个汇编语言（ASM,Assembly Language）的程序，这个过程叫编译（Compile）。针对汇编代码，可以再使用汇编器（Assembler）翻译成机器码（就是0 1表示的计算机指令），这时候才是CPU能够认识的计算机指令。

```
// test.c
int main()
{
  int a = 1; 
  int b = 2;
  a = a + b;
}
```

在Linux操作系统上，通过gcc 和 objdump两个命令可以把对应的汇编代码和机器码打印出来：

```
$ gcc -g -c test.c
$ objdump -d -M intel -S test.o  
```

<img src="https://liuyang-picbed.oss-cn-shanghai.aliyuncs.com/img/67cf3c90ac9bde229352e1be0db24b5b.png" alt="img" style="zoom:50%;" />

**实际环境中，GCC 编译的时候，可以直接将代码编译成机器码，汇编代码其实就是“给程序员看的机器码”，机器码和汇编代码是一一对应的。**

计算机指令比较多，常见的指令可以分为五大类：
（1）算术类指令，我们的加减乘除，都会变成一条条算术指令。
（2）数据传输指令，给变量赋值，在内存里面读写数据，用的都是数据传输类指令。
（3）逻辑类指令，逻辑上的与或非，都是这一类指令。
（4）条件分支类指令。我们日常写的“if/else”，其实都是条件分支类指令。
（5）无条件跳转指令，通常是函数或则方法，在调用函数的时候，其实就是发起了一个无条件跳转指令。

<img src="https://liuyang-picbed.oss-cn-shanghai.aliyuncs.com/img/ebfd3bfe5dba764cdcf871e23b29f197.jpeg" alt="img" style="zoom: 33%;" />

除C这样的编译型的语言之外，例如解释型的Python 和 虚拟机语言JAVA，他们最终都是都是要转成机器码来执行的，只是，解释型语言是通过解释器在程序运行的时候逐句翻译，而JAVA这样的虚拟机语言，则是由虚拟机对编译出来的中间代码（.class文件）进行解释或则即时编译成为机器码来最终执行。

##### 二、指令跳转和寄存器

CPU里面有很多用来存储数据和内存地址的寄存器，比如整数寄存器、浮点数寄存器、向量寄存器和地址寄存器等。有些寄存器可以存放数据，又能存放地址，叫做通用寄存器。

CPU中还有三个比较特殊的寄存器：
（1）PC寄存器（Program Counter Register）,叫做指令地址寄存器（Instruction Address Register）。用来存放下一条需要执行的计算机指令的内存地址。
（2）指令寄存器（Instruction Register），用来存放当前正在执行的指令。
（3）条件码寄存器（Status Register）,用里面的一个一个标志位（Flag）,存放CPU进行算术或则逻辑计算的结果。如果比较的结果是 True，也就是 r == 0，就把零标志条件码（对应的条件码是 ZF，Zero Flag）设置为 1。除了零标志之外，Intel 的 CPU 下还有进位标志（CF，Carry Flag）、符号标志（SF，Sign Flag）以及溢出标志（OF，Overflow Flag），用在不同的判断条件下使用。

<img src="https://liuyang-picbed.oss-cn-shanghai.aliyuncs.com/img/ad91b005e97959d571bbd2a0fa30b48a.jpeg" alt="img" style="zoom: 33%;" />

一个程序执行的时候，CPU会根据PC寄存器里的地址，从内存里面把需要执行的指令读取到指令寄存器里面执行，然后根据指令长度自增，开始顺序读取下一条指令（一个程序的一条条指令，在内存里面是连续保存的，也会一条条加载）。

有些特殊指令，比如 j 类指令，也就是跳转指令，会修改PC寄存器里面的地址值，这样，下一条要执行的指令就不是从内存里面顺序加载了。这也是我们在写程序的时候可以使用if...else 和 while/for 的原因。

<img src="https://liuyang-picbed.oss-cn-shanghai.aliyuncs.com/img/b439cebb2d85496ad6eef2f61071aefa.jpeg" alt="img" style="zoom:33%;" />

##### 三、程序栈

###### 1、为什么需要程序栈

在多层函数调用里面，只记录一个地址是不够的，函数调用没有数量的限制，在所有函数调用返回之前，每一次的返回地址都需要记录下来（例如，A调B，D调B，不记录返回地址的话，调完B后是不知道返回到哪儿继续执行的），但是我们CPU的寄存器数量并不多。

<img src="https://liuyang-picbed.oss-cn-shanghai.aliyuncs.com/img/d0c75219d3a528c920c2a593daaf77be.jpeg" alt="img" style="zoom: 25%;" />

我们在内存里面开辟一段空间，用栈这个后进先出的数据结构。栈就像一个乒乓球桶，每次程序调用函数之前，我们都把调用返回后的地址写在一个乒乓球上，然后塞进这个球桶，就是 **压栈** 。如果函数执行完了，就从球桶里取出最上面的那个求，这就是 **出栈**。球桶的底部，就是 **栈底**，最上面的乒乓球所在的位置，就是 **栈顶**。

**压栈** 的其实不只有函数调用完成后的返回地址，还包括函数调用传输的参数数据等，整个函数所占用的内存空间，就是函数的 **栈帧**。

###### 2、为什么会stack overflow

栈的大小有限，如果函数的调用层数太多，我们往栈里面压入它存不下的内容，程序在执行的过程中就会遇到栈溢出的错误。