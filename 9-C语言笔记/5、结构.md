**1、结构的基本知识**
结构是一个或多个变量的集合，这些变量可能为不同的类型，为了处理的方便而将这些变量组织在一个名字之下。由于结构将一组相关的变量看作一个单元而不是各自独立的实体，因此结构有助于组织复杂的数据，特别是在大型的程序中。
使用坐标举例，我们声明结构来存放坐标：
```
struct point {
    int x;
    int y;
};
```
关键字strcut引入**结构声明**。结构声明由包含在花括号内的一系列声明组成。关键字struct后面的名字是可选的，称为结构标记(这里是point)。
结构标记用于为结构命名，在定义之后，结构标记就代表花括号内的声明，可以用它作为该声明的简写形式。
```
struct point pt;
```
如果没有结构标记，那么声明就需要这么写了：
```
struct { ... }  x, y, z;
```
如果结构声明后面不带变量表，则不需要为它们分配存储空间，它仅仅描述了一个结构的模板。
结构中定义的变量称为成员。结构成员、结构标记和普通变量可以采用相同的名字，它们之间不会冲突，因为通过上下文分析总可以对它们进行区分。

**结构的初始化**可以在定义的后面使用初值进行。初值表中同每个成员对应的初值必须是常量表达式，例如：
```
struct point maxpt = {320, 200};
```
自动结构(局部变量)也可以通过赋值初始化，还可以通过调用返回相应类型结构的函数进行初始化。

**结构成员的访问**可以通过运算符"."引用某个特定结构的成员 ：
```
结构名.成员

printf("%d,%d", pt.x, pt.y);
```

**结构嵌套**，结构可以嵌套结构，如：
```
struct rect{
    struct point pt1;
    struct point pt2;
}

....

//声明和访问
struct rect screen;
screen.pt1.x;
```

**2、结构与函数**
结构的合法操作只有几种：作为一个整体复制和赋值，通过&运算符取地址，访问其成员。其中，复制和赋值包括向函数传递参数以及从函数返回值。结构之间不可以进行比较。可以用一个常量成员值列表初始化结构，自动结构也可以通过赋值进行初始化。
下面代码示例了结构传递得部分用法：
```
/* makepoint函数：通过 x，y坐标构造一个点*/
struct point makepoint(int x, int y){
    struct point temp;
    temp.x = x;
    temp.y = y;
    return temp;
}

/* 可以通过makepoint函数动态地初始化任意结构，也可以向函数提供结构类型的参数*/
struct rect screen;
struct point middle;
struct point makepoint(int, int);
screen.pt1 = makepoint(0, 0);
screen.pt2 = makepoint(XMAX, YMAX);
middle = makepoint((screen.pt1.x + screen.pt2.x)/2, (screen.pt1.y + screen.pt2.y)/2);

/*addpoint 函数：将两个点相加*/
struct point addpoint(struct point p1, struct point p2){
    p1.x += p2.x;
    p1.y + = p2.y;
    return p1;
}

```
**注意，结构类型的参数和其他类型参数一样，都是通过值传递的。所以参数p1 和 p2都是复制的传入的值，返回也同样是值。**

如果传递给函数的结构很大，使用指针方式的效率通常比复制整个结构的效率要高。结构指针类似与普通指变量指针，声明：
```
struct point *pp;
```
将pp定义为一个指向struct point类型对象的指向。\*pp即为结构，而(\*pp).x 和(\*pp).y则是结构成员。
C语言还提供了另一种简写方式，来访问结构成员：
```
pp->结构成员  // pp为指向结构的指针

 printf("%d, %d", pp->x, pp->y);
```

**3、结构数组**

结构和其它类型一样，也可以声明数组形式，如：
```
//声明了结构类型key，并定义了该类型的结构数组keytab，同时为其分配存储空间。
struct key{
    char * word;
    int count;
} keytab[NKEYS];

//可以利用标记进行数组定义
struct key{
    char *word;
    int count;
}

struct key keytab[NKEYS];
```
结构数组初始化，可以在定义的后面通过初值表进行初始化：
```
struct key{
    char *word;
    int count;
} keytab[] = {
    {"auto", 0},
    {"break", 0},
    ...
}
// 如果初值是简单变量或者字符串，并且其中的任何值都不为空，则内层的花括号可以省略。
```

**4、指向结构的指针**
......

**5、自引用结构**
在二叉树的数据结构很常用
```
struct tnode{ /* 树的节点 */
    char * word;
    int count;
    struct tnode *left;
    struct tnode *right;
}
```
这种对节点的递归的声明方式看上去好像是不确定的，但它的确是正确的。一个包含其自身实例的结构是非法的。不过指针是合法的。

**6、表查找**
......

**7、类型定义（typedef）**
C语言提供了一个称为typedef的功能，它用来建立新的数据类型名，例如，声明
typedef int Length;
将Length定义为与int具有同等意义的名字。类型Length可用与类型声明、类型转换等，它和类型int完全相同，例如：
```
Length len, maxlen;
Length *lengths[];
```
上面定义的树节点可以重新定义，如下：
```
typedef struct tnode *Treeptr;
typedef struct tnode{
    char *word;
    int count;
    Treeptr left;
    Treeptr right;
} Treenode;

```
-从任何意义上讲，typedef声明并没有创建一个新类型，它只是为某个已存在的类型增加了一个新的名称而已。
-typedef声明也没有增加任何新的语义，通过这种方式声明的变量与通过普通声明方式声明的变量具有完全相同的属性。

使用typedef可以使程序参数化，以提高程序的可移植性。如果typedef声明的数据类型同机器有关，那么当程序迁移到其他机器上时，只需要改变typedef类型定义就可以了。
使用typedef为程序提供更好的说明性——Treeptr类型显然比一个声明为指向复杂结构的指针更容易让人理解。

**8、联合**
联合是可以（在不同时刻）保存不同类型和长度的对象的变量，编译器负责跟踪对象的长度和对齐要求。
联合的目的——一个变量可以合法地保存多种数据类型中的任何一种类型的对象，其语法基于结构，如下所示：
 ```
union u_tag{
    int ival;
    float fval;
    char *sval;
} u;
```
变量u必须足够大，以保存这3种类型中最大的一种，具体长度同具体实现有关。这些类型中的任何一种类型的对象都可以赋值给u。

**联合读取的类型必须是最近一次存入的类型。程序员负责跟踪当前保存在联合中类型。**

可以通过下列语法**访问联合中的成员**（它与访问结构的方式相同）：
```
联合名.成员
或
联合指针->成员
```
假设变量utype跟踪保存着在u中的当前数据类型，则可以像下面这样使用联合：
```
if(utype == INT)
    printf("%d\n", u.ival);
else if(utype == FLOAT)
    printf("%f\n", u.fval);
else if(utype == STRING)
    printf("%s\n", u.sval);
else
    printf("bad type %d in utype\n", utype);
```

实际上，联合就是一个结构，它的所有成员相对于基地址的偏移量都是为0，此结构空间要大到足够容纳最宽的成员，并且，其对齐方式要适合联合中所有类型的成员。
对联合允许的操作与对结构的操作相同：作为一个整体单元进行赋值、复制、取地址及访问其中一个成员。
**联合只能用第一个成员类型的值进行初始化**，因此，上述联合u只能用整数值进行初始化。

**9、位字段**
在存储空间很宝贵的情况下，有可能需要将多个对象保存在一个机器字中。它主要用于一些使用空间很宝贵的程序设计中，如嵌入式程序设计。
C语言提供了直接定义和访问一个字中的位字段的能力，而不需要通过按位逻辑运算符。位字段（bit-field），是“字”中相邻位的集合。“字”word是单个的存储单元，它同具体的实现有关。

位字段定义如下：
```
typedef struct bit_field {
    unsigned int a : 5;
    unsigned int b : 3;
    unsigned int c : 20;
    unsigned int d : 4;
} bit_field_s;
```
在如上定义中，bit_field_s只占用一个DWORD（假设word占2个字节）的空间，即4个字节。其中成员a占用5位，成员b占用3位，成员c占用20位，成员d占用4位。我们可以对bit_field_s的成员进行如下赋值：
```
bit_field_s x；
x.a = 4;
x.b = 7;
x.c = 1024;
x.d = 13;
```
在定义位字段时还可以不指定成员的名称，看如下定义：
typedef struct bit_field {
unsigned int a : 5;
unsigned int b : 3;
unsigned int c : 20;
unsigned int : 4;
} bit_field_s;

在如上定义中，最后一个成员只是用于占位，使结构体按DWORD对齐。而如下定义就和上面的定义是一样的效果：
typedef struct bit_field {
unsigned int a : 5;
unsigned int b : 3;
unsigned int c : 20;
unsigned int : 0;
} bit_field_s;
最后一个成员没有名称，无名字段起填充作用，特殊宽度0可以强制在下一个字边界上对齐。

成员访问与结构类似。

**对于位字段中的成员不能用位操作符进行运算，因为它们没有地址。**
某些机器上字段的分配是从字的左端至右端进行的，而有些机器上则相反，这意味着，尽管字段对维护内部定义的数据结构很有用，但在选择外部定义数据的情况下，必须仔细考虑大小端问题。依赖这些因素的程序是不可移植的。









