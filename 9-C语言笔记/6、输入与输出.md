**1、标准输入/输出**
标准库实现了简单的文本输入/输出模式。文本流由一系列行组成，每一行的结尾是一个换行符。如果系统没有遵循这种模式，则标准库将通过一些措施使得该系统适应这种模式。例如，标准库可以在输入端将回车符和换页符都转换为换行符，而在输出端进行反向转换。

最简单但输入机制是使用getchar函数从标准输入中（一般为键盘）一次读取一个字符：
```
int getchar(void);
```
getchar函数在每次调用是返回下一个输入字符。若遇到文件结尾，则返回EOF。符号常量EOF在头文件<stdio.h>中定义，其值一般为-1，但程序中应该使用EOF来测试文件是否结束，这样才能保证程序同EOF的特定值无关。
在许多环境中，**可以使用\<来实现输入重定向**，例如将标准输入替换为文件输入：如果程序prog中使用来函数getchar函数，则命令行
```
prog < infile
```
将使得程序prog从输入文件infile中读取字符。程序prog本身并不在意输入方式的改变，并且，“
\<infile”也并不包含在argv的命令行参数中（此处不清楚可参见，指针与数组模块的命令行参数）。
如果输入通过管道机制来自另一个程序，比如，在某些系统中，下列命令行：
```
otherprog | prog
```
将运行两个程序otherprog和prog，并将程序otherprog的标准输出通过管道重定向到程序prog的输入上。

函数
```
int putchar(int)
```
用于输出数据。putchar(c)将字符c送至标准输出上，在默认情况下，标准输出为屏幕显示。如果没有发生错误，则函数putchar将返回输出的字符；如果发生来错误，则返回EOF。
同样，通常情况下，也可以使用“\>输出文件名”的格式将输出重定向到某个文件中。例如，如果程序prog调用了函数putchar，那么命令行
```
prog >输出文件名
```

printf函数也向标准输入设备上输出数据。

**2、格式化输出——printf函数**
输出函数printf将内部数值转换为字符的形式。
```
int printf(char *format, arg1, arg2, ...)
```
函数printf在输出格式format的控制下，将其参数进行转换与格式化，并在标准输出设备上打印出来。它的返回值为打印的字符数。

格式字符串包含两种类型的对象：普通字符和**转换说明**。在输出时，普通字符将原样不动地复制到输出流中，而转换说明并不直接输出到输出流中，而是用于控制printf中参数的转换和打印。
**转换说明符**都有一个百分号字符（%）开始，并以一个转换字符结束。在字符%和转换字符中间可能依次包含下列组成部分：
-负号，用于指定被转换的参数按照左对齐的形式输出。
-数，用于指定最小字段宽度。转换后的参数将打印不小于最小宽度的字段。如果有必要，字段左边（如果使用左对齐的方式，则为右边）多余的字符位置用空格填充以保证最小宽度。
-小数点，用于将字段宽度和精度分开。
-数（小数点后面的），用于指定精度，即指定**字符串中要打印的最大字符数**、**浮点数小数点后的位数**、**整型最少输出的数字数目**。
-字母h或l，字母h表示将整数作为short类型打印，字母l表示将整数作为long类型打印。
**pringf函数基本的转换说明如下：**
![转换说明.png](https://liuyang-picbed.oss-cn-shanghai.aliyuncs.com/2020-12-08-145760.png)

下面示例，打印“hello, world”(12个字符)说明了不同的转换说明产生的不同结果（添加冒号是为了更清晰地表示）：
```
:%s:                    :hello, world:
:%10s:                :hello, world:
:%.10s:               :hello, wor:
:%-10s:               :hello, world:
:%.15s:               :hello, world:
:%-15s:               :hello, world   :
:%15.10s:           :     hello, wor:
:%-15.10s:          :hello, wor     :
```

在转换说明中，宽度或精度可以用星号\*表示，这时，宽度或精度的值通过转换下一参数（必须为int类型）来计算。例如，为了从字符串s中打印最多max个字符，可以使用下列语句：
```
printf("%.*s", mas, s);
```

sprintf函数和printf函数形同，但它将输出保存到一个字符中（printf默认标准输出）：
```
int sprintf(char *string, char *format, arg1, arg2, ...)
```
函数printf的参数是可变长的，声明形式如下：
```
int printf(char *fmt, ...)
```
省略号表示参数表中的数量和类型是可变的。

**3、格式化输入——scanf函数**
输入函数scanf对应于输出函数printf，它在与后者相反的方向上提供同样的转换功能。具有变长参数表的函数scanf的声明形式如下：
```
int scanf(char *format, ...)
```
scanf函数从标准输入中读取字符序列，按照format中的格式说明对字符序列进行解释，并把结果保存到其余的参数中。
除格式参数format，其他所有参数都必须是指针，用于指定经格式转换后的相应输入保存的位置。
当scanf函数扫描完其个格式串，或则碰到某些输入无法与格式控制说明匹配的情况时，该函数将终止，同时，成功匹配并赋值的输入项的个数将作为函数返回，所以该函数的返回值可以用来确定已匹配的输入个数。如果到底文件的结尾，该函数将返回EOF。

函数sscanf也是输入函数，它用于从一个字符串（而不是标准输入）中读取字符序列：
```
int sscanf(char *string, char *format, arg1,arg2, ...)
```
它按照格式参数format中规定的格式扫描字符串string，并把结构分别保存到arg1，arg2，... 这些参数也必须是指针。

**格式串**通常都包含转换说明，用于控制输入的转换，格式串可能包含下列部分：
-空格或制表符，在处理过程中将被忽略。
-普通字符串（不包括%），用于匹配输入流中下一个**非空白符字符**。
-转换说明，依次由一个%、一个可选的赋值禁止字符\*、一个可选的数值（指定最大字段的宽度）、一个可选的h、l或L字符（指定目标对象的宽度）以及一个转换字符组成。

**转换说明**控制下一个输入字段的转换。一般来说，转换结果存放在相应的参数指向的变量中。但是，如果转换说明中有赋值禁止符\*，则跳过该输入字段，不进行赋值。
**输入字段**定义为一个不包含空白符的字符串，其**边界定义为到下一个空白符或达到指定的字段宽度**（空白符包括空格符、横向制表符、换行符、回车符、纵向制表符以及换页符）。

转换说明，在百度百科上说得比较精确，可以参见[scanf函数](https://baike.baidu.com/item/scanf/10773316)

**4、文件访问**
在读写一个文件之前，必须通过库函数fopen打开文件。fopen用类似与x.c或y.c这的外部名与操作信息进行某些必要的连接和通信（我们不关心这些细节），并返回一个随后可以用于文件读写操作的指针。
**文件指针**，它指向一个包含文件信息的结构，这些信息包括：缓冲区的位置、缓冲区中当前字符的位置、文件的读或写状态、是否出错或是否已经到达文件结尾等等。用户不必关心这些细节，因为\<stdio.h\>中已经定义了一个包含这些信息的结构FILE。在程序中只需要按照下列方式声明一个指针即可：
```
FILE *fp;
FILE *fopen(char *name, char *mode);
```
fp是一个指向结构的FILE指针，注意，FILE想int类型一样是一个类型名，而不是机构标记。它是通过typedef定义的。
在程序中可以这样调用foper函数：
```
fp = fopen(name, mode);
```
fopen的第一个参数是一个字符串，它包含文件名。第二个参数是访问模式，也是一个字符串，用于指定文本的使用方式。允许的模式包括：读（“r”）、写（“w”）及追加（“a”）。某些系统还区分文本文件和二进制文件，对后者的访问需要在模式字符串中增加字符“b”。
如果打开一个不存在的文件用于写或追加，该文件将被创建（如果可能的话）。当以写方式打开一个已存在的文件时，该文件原来的内容将被覆盖。但是，如果以追加方式打开一个文件，则该文件原来的内容将保持不变。读一个不存在的文件或导致错误，其他一些操作也可能导致错误，比如试图读取一个无读取权限的文件。如果发生错误，fopen将返回NULL。
文件被打开后，就需要考虑采用哪种方法对文件进行读写。有多种方法可供考虑，其中，getc和putc函数最简单。getc从文件中返回下一个字符，它需要知道文件指针，以确定对哪个文件执行操作：
```
int getc(FILE *fp);
```
getc函数返回fp指向的输入流中的下一个字符。如果到达文件尾或出现错误，该函数将返回EOF。
putc是一个输入函数，如下所示：
```
int putc(int c, FILE *fp);
```
该函数将字符c写入到fp指向的文件中，并返回写入的字符。如果发生错误，则返回EOF。

**启动一个C语言程序时，操作系统环境负责打开3个文件，并将这3个文件的指针提供给该程序。这3个文件分别是标准输入、标准输出和标准错误，相应的文件指针分别为stdin、stdout和stderr，它们在\<stdio.h\>中声明。**在大多数环境中，stdin指向键盘，而stdout和stderr指向显示器。
getchar和putchar函数可以通过getc、putc、stdin及stdout定义如下：
```
#define getchar() getc(stdin)
#define putchar(c) putc((c), stdout)
```

对于文件的格式化输入或输出，可以使用函数fscanf和fprintf。它们与scanf和printf函数的区别仅仅在于它们的第一个参数是指向所需读写的文件的指针，第二个参数是格式串。如下所示：
```
int fscanf(FILE *fp, char *format, ...)
int fprintf(FILE *fp, char *format, ...)
```

函数
```
int fclose(FILE *fp)
```
执行和fopen相反的操作，**它断开有fopen函数建立的文件指针和外部名之间的连接，并释放文件指针以供其他文件使用**。因为大多数操作系统都限制了一个程序可以同时打开的文件数，所以，当文件执行不需要时就释放。对输出文件fclose还有另外一个原因：它将把缓冲区中的putc函数正在收集的输出写到文件中。

**5、错误处理——stderr和exit**
标准错误文件sterr就是程序打开时，被打开的三个文件之一。即使对标准输出进行了重定向，写到stderr中的输出通常也会显示在屏幕上。
```
...
if(ferror(stdout)){
    fprintf(stderr, "%s: error writing stout\n", prog);
    exit(2);
}
...
```
fprintf函数产生的诊断信息输出到stderr上，因此诊断信息将会显示在屏幕上，而不是仅仅输出到管道或输出文件中。
标准库函数exit，当该函数被调用时，它将终止调用程序的执行。任何调用该程序的进程都可以获取exit的参数值。按照惯例，返回值0表示一切正常，而非0返回值通常表示出现了异常情况。exit为每个已打开的输出文件调用fclose函数，以将缓冲区中的所有输出写到相应的文件中。
主程序main中，语句return exp 等价于exit(expr)。但是，使用函数exit有一个优点，它可以从其他函数中调用。

ferror和函数 int feof(FILE*)类似，如果指定的文件到达文件尾，它将返回一个非0值。

**6、行输入和行输出**
标准库提供一个输入函数fgets
```
char *fgets(char *line, int maxline, FILE *fp)
```
fgets函数从fp指向的文件中读取下一个输入行（包括换行符），并将它房子字符数组line中，它最多可读取maxline - 1个字符。读取的行将以'\0'结尾保存到数组中。通常情况下，fgets返回line，但如果遇到了文件结尾或发生了错误，则返回NULL。

输出函数fputs将一个字符串（不需要包含换行符）写入到一个文件中：
```
int fputs(char *line, FILE *fp)
```
如果发生错误，该函数将返回EOF，否则返回一个非负值。

库函数gets和puts的功能与fgets和fputs函数类似，但它们是对stdin和stdout进行操作。gets函数在读取字符串是将删除结尾的换行符（'\n'）,而puts函数在写入字符串时将在结尾添加一个换行符。

**7、其他函数**
标准库提供了很多功能各异的函数。本节将对其中特别有用对函数做一个简单概述。

**7.1**字符串操作函数
它们都在头文件<string.h>中定义。在下面都各个函数中，s与t为char *类型，c与n为int类型。
strcat(s, t) ——将t指向的字符串连接到s指向的字符串的末尾
strncat(s, t, n)——将t指向的字符串中前n个字符连接到s指向的字符串的末尾

strcmp(s, t)——根据s指向的字符串小（s<t）、等于（s == t）或大于（s>t）t指向的字符串的不同情况，分别返回负数、0或正整数
strncmp(s, t, n)——同strcmp相同，但只在前n个字符中比较

strcpy(s, t)——将t指向的字符串复制到s指向的位置
strncpy(s, t, n)——将t指向的字符串中前n个字符复制到s指向的位置

strlen(s)——返回s指向的字符串的长度
strchar(s, c)——在s指向的字符串中查找c，若找到，则返回指向它第一次出现的位置的指针，否则返回null
strrchar(s, c)——在s指向的字符串中查找c，若找到，则返回指向它最后一次出现的位置的指针，否则返回null

**7.2**字符类别测试和转换函数
头文件中<ctype.h>中定义了一些用于字符测试和转换的函数。在下面各个函数中，c是一个可表示为unsigned char类别或EOF的int对象。该函数的返回值为int。
isalpha(c)——若c是字母，则返回一个非0值，否则返回0
isupper(c)——若c是大写字母，则返回一个非0值，否则返回0
islower(c)——若c是小写字母，则返回一个非0值，否则返回0
isdigit(c)——若c是数字，则返回一个非0值，否则返回0
isalnum(c)——若isalpha(c)或isdigit(c)，则返回一个非0值，否则返回0
isspace(c)——若c是空格、横向制表符、换行符、回车符、换页符或纵向制表符，则返回一个非0值
toupper(c)——返回c的大写形式
tolower(c)——返回c的小写形式

**7.3**ungetc函数
标准库提供了一种称为ungetc的函数，该函数将字符c写回到文件fp中。如果执行成功，则返回c，否则返回EOF。每个文件只能接受一个写回字符。ungetc函数可以和任何一个输入函数一起使用，比如scanf、getc或getchar。
```
int ungetc(int c, FILE *fp)
```

**7.4**命令执行函数
函数system(char*s)执行包含在字符串s中的命令，然后继续执行当前程序。s的内容在很大程度上与所用的操作系统有关。下面来看一个unix操作系统环境的小例子，语句
```
system("date");
```
将执行程序date，它在标准输出上打印当天的日期和时间。system函数返回一个整型的状态值，其值来自于执行的命令，并同具体系统有关。在unix系统中，返回的状态是exit的返回值。

**7.5**存储管理函数
函数malloc和calloc用于动态地分配存储块。函数malloc的声明如下：
```
void *malloc(size_t n)
```
当分配成功时，它返回一个指针，该指针指向n字节长度的未初始化的存储空间，否则返回NULL。

函数calloc的声明如为：
```
void *calloc(size_t n, size_t size)
```
当分配成功时，它返回一个指针，该指针指向的空闲空间足以容纳n个指定长度对象组成的数组，否则返回NULL。该存储空间被初始化为0。

free(p)函数是否p指向的存储空间，其中，p是此前通过调用malloc或calloc函数得到的指针。**存储空间的释放顺序没有限制，但是，如果释放一个不是通过调用malloc或calloc函数得到的指向所指向的存储空间，将是一个严重的错误。**


**7.6**数学函数
头文件<math.h>中声明来20多个数学函数。下面介绍一些常用的数学函数，每个函数带一个或两个double类型的参数，并返回一个double类型的值。
sin(x)——x的正弦函数，其中x用弧度表示
cos(x)——x的余弦函数，其中x用弧度表示
atan2(x, y)——y/x的反正切函数，其中x 和 y用弧度表示
exp(x)——指数函数e x
log(x)——x的自然对数(以e为底)，其中，x>0
log10(x)——x的常用对数(以10为底)，其中x>0
pow(x, y)——计算x的y次方
sqrt(x)——x的平方根(x>= 0)
fabs(x)——x的绝对值

**7.7**随机数发生器函数
函数rand()生成介于0和RAND_MAX之间的伪随机整数序列。其中RAND_MAX是在头文件<stdlib.h>中定义的符号常量。下面是一种生成大于等于0但小于1的随机浮点数的方法：
```
#define frand() ((double) rand() / (RAND_MAX + 1.0))
```








