**1、指针与地址**
通常的机器都有一系列连续编号或编址的存储单元，这些存储单元可以单个进行操作，也可以以连续成组的方式操作。指针是能够存放一个地址的一组存储单元。
一元元素符&可用于取一个对象的地址：
```
p = &c;
```
将把c的地址赋值给变量p，我们称p为“指向”c的指针。地址运算符&只能用于内存（RAM）中的对象，即变量与数组元素，**它不能作用于表达式、常量或register类型的变量**。（严格地说，是取地址运算符不能作用于常量字面量上。因为从翻译后的二进制的角度来讲，这些直接书写在代码里的常量字面量是由硬件直接产生的，是不具有地址属性的。但是 C/C++ 里平常说的常量一般指的是常变量，即经 const 关键字修饰的变量。const 变量经初始化赋值后不可再修改。但是从二进制的角度来讲，它与变量无任何区别，同样是存储在内存中，因此可以取地址。const 的属性只是编译器层面在编译时候的检查与保护而已。）
一元运算\*是间接寻址或间接引用运算符。当它作用于指针时，将访问指针所指向的对象。
```
int x = 1,y = 2, z[10];
int *ip; /* ip是指向int类型的支持*/

ip = &x;  /*ip现在指向x*/
y = *ip; /*y的值现在为1*/
*ip = 0; /*x的值现在为0*/
ip = &z[0];/*ip现在指向z[0]*/
```
指针只能指向某种特定类型的对象，也就是说，每个指针都必须指向某种特定的数据类型（void类型的指针例外，可以存放指向任何类型的指针）。

**2、指针与函数参数**
指针参数使得被调用函数能够访问和修改主调函数中对象的值。
例如，交换两个元素：
```
void swap(int *px, int *py){
    int temp;
    temp = *px;
    *px = *py;
    *py = temp;
}
```

**3、指针与数组**
通过数组下标所能完成的任何操作都可以通过指针来实现。
举例说明：定义来一个长度为10的数组a（假设里面对象是int类型），这10个对象存在相邻的内存区域中，名字分别为a[0]、a[1]...a[9]。a[i]表示数组的第i个元素。我们可以声明 int  *pa;  然后给pa赋值 ，pa = &a[0]，则可以将指针pa指向数组a的第0个元素。pa + 1将指向pa所指向数组元素之后的那一个元素，这里的 +1 并不是地址值+1，+1后的地址值由指针指向的对象类型决定，如果这个类型占来4个字节，那么+1后的地址值实际是加了4，只有这样才能保证+1后指向下一个元素。
```
    int arr[] = {1,3,5};
    int *arrp = arr;
    printf("%p\n",arrp);
    printf("%p\n",arrp + 1);
```
测试结果：
0x7ffee92da5dc
0x7ffee92da5e0
其实数组名本身代表的就是该数组最开始的一个元素地址，所以pa = &a[0] 又可以写成 pa = a。

一个通过数组和下标实现的表达式可等价地通过指针和偏移量实现。如pa[i] 与*(pa +i)就是访问a[i]这个元素。

数组名和指针之间又一个不同处，指针是一个变量，因此pa=a和 pa++都是合法的。但数组名不是变量（数组名就是指向第一个元素地址），因此a=pa和a++形式语句都是非法的（a+i 这种指向第i个元素是合法的）。

**当把数组名传递给一个函数时，实际下传递的是该数组的第一个元素地址**。所以在函数定义中，形式参数char s[]和 char *s 是等价的。

**4、地址算术运算**
有效的指针运算包括：
-相同类型指针之间的赋值运算。
-指针同整数之间的加法或减法运算。
-指向相同数组元素的两个指针间的减法或比较运算（可用于判断先后）
-将指针赋值为0或指针与0之间的比较运算。

指针同整数之间的加减法运算就是上面的pa + 1介绍。
指向相同数组元素的两个指针间的减法运算可以计算两者间的元素个数。
```
int strlen(char *s){
    char *p = s;
    while(*p != '\0'){
        p++;
    }
    return p - s;
}
```
C语言保证，0永远不是有效的数据地址。程序中经常用符号常量NULL代替常量0，这样便于更清晰地说明常量0是指针的一个特殊值。

**5、字符指针与函数**
字符串常量是一个字符数组，例如：
"I am a string"  在字符串的内部表示中，字符数组以空字符'\0'结尾，所以程序可以通过检测空字符找到字符数组的结尾。字符串常量占据的存储单元数也因此比双引号内的字符数大1。

标准库中的很多函数都是使用字符指针作为参数。

**6、指针数组以及指向指针的指针**
由于指针本身也是变量，所以它们也可以像其他变量一样存储在数组中。
形式如：
```
char * lineptr[MAXLINES];
```
char * lineptr[]   char **s  s就是指向指向char类型的指针的指针。

**7、多维数组**
C语言提供了类型矩阵的多维数组，但实际上它们并不像指针数组使用得那样广泛。
用二维数组示例：
```
static char daytab[2][13] = {
    {0,31,28,31,30,31,30,31,31,30,31,30,31},
    {0,31,29,31,30,31,30,31,31,30,31,30,31},
};

/* day_of_year函数：将某月某日的日期表示形式转换为某年中第几天的表示形式*/
int day_of_year(int year, int month, int day)
{
    int i, leap;
    leap = year%4 == 0 && year%100 == 0 || year%400 == 0;
    for(i = 1; i < month; i++){
        day += daytab[leap][i];
    }
    return day;
}

/* month_day 函数：将某年中第几天的日期表示形式转换为某月某日的表示形式*/
void month_day(int year, int yearday, int *pmonth, int *pday)
{
    int i, leap;
    leap = year%4 == 0 && year%100 != 0 || year%400 == 0;
    for(i = 1; yearday > daytab[leap][i]; i++){
        yearday -= daytab[leap][i];
    }
    *pmonth = i;
    *pday = yearday;
}
```
如果将二维数组作为参数传递给函数，那么在参数声明中必须指明数组的列数，数组的行数没有太大关系，因为前面已经讲过，函数调用时传递的是一个指针（指针指向的对象类型必须清楚，知道了对象元素的大小才能进一步寻址到其它元素），它指向由行向量构成的一维数组。一般来说除数组的第一维下标可以不用指定大小外，其余各维都必须明确指定大小。
```
f(int daytab[2][13]){...}
//也可以写成
f(int daytab[][13]){...}
//还可以写成
f(int (*daytab)[13]){...}
```

**8、指针数组的初始化**
指针数组的初始化语法和之前的类型对初始化语法类型：
```
char *name[] = {"January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"}
```
name数组的初始化通过一个字符串列表实现，列表中的每个字符串赋值给数组相应位置的元素。第i个字符串的所有字符存储在存储器中的某个位置，指向它的指针存储在name[i]中。

**9、指针（数组）与多维数组**
指针数组最频繁的用处是存放具有不同长度的字符串。而一个二维数组存储字符串长度都是有固定限制的。
例如：
```
//指针数组是连续空间，每个指针元素指向的空间各自连续。
char *name[] = {"January", "February", "March"}; //占用的存储空间 8 + 9 + 6 = 23个字节

//多维数组整体连续空间
char aname[][15] = {"January", "February", "March"}; //占用存储空间 15 + 15 + 15 = 45个字节 
```

**10、命令行参数**
在支持C语言的环境中，可以在程序开始执行时将命令行参数传递给程序。调用主函数main时，它带有两个参数，第一个参数（argc，用于参数计数）的值表示允许程序时命令行中参数的数目；第二个参数（argv，用于参数向量）是一个执行字符串数组的指针，其中每个字符串对于一个参数。
```
main(int argc, char *argv[]){
    ...
}
```
按照C语言的约定，argv[0]的值是启动该程序的程序名，因此argc的值至少为1。
如命令（命令行中各参数之间用空格隔开）:
echo hello, world  将打印输出 hello, world
在示例中，argc的值为3，argv[0]、argv[1]和argv[2]的值分别为"echo"、"hello,"以及"world"。第一个可选参数为argv[1]，而最后一个可选参数为argv[argc - 1]。另外ANSI标准要求argv[argc]的值必须为一空指针（NULL即0）。

**11、指向函数的指针**
函数本身不是变量，但可以定义指向函数的指针。这种类型的指针可以被赋值、存放在数组中、传递给函数以及作为函数的返回值等等。
```
int (*comp)(int, int);
```
这个示例表明comp是一个指向函数的指针，该函数具有两个int类型的参数，其返回值类型为int。在定义函数指针时(\*comp) 括号不能少，否则就变成了 int \*comp(int,int);声明了一个函数有两个int参数并且返回指向int类型的指针。
comp的类型是 int(\*)(int, int)。
调用函数  (\*comp)(1, 2);

**12、复杂声明**
...这个确实比较复杂，特别是涉及函数指针的语法。复杂声明需要结合预算符优先级和运算符的结合性来分析。
```
char **argv
    argv: pointer to pointer to char
int (*daytab)[13]
    daytab: pointer to array[13] of int
int *daytab[13]
    daytab: array[13] of pointer to int
void *comp()
    comp: function returning pointer to void
void (*comp)()
    comp: pointer to function returning void

// 下面两个比较复杂
char (* (*x()) [])()
    x: function returning pointer to array[] of pointer to function returning char
char (* (*x[3])() )[5]
    x: array[3] of pointer to function returning pointer to array[5] of char
```




