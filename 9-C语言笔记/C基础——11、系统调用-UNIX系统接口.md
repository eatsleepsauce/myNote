#### 系统调用，UNIX系统接口

UNIX操作系统通过一系列的系统调用提供服务，这些系统调用实际上是操作系统内的函数，它们可以被用户程序调用。C语言程序中使用一些重要的系统调用。我们经常需要借助于系统调用以获得最高效率，或者访问标准库中没有的某些功能。

**在任何特定的系统中，标准库函数的实现必须通过宿主系统提供的功能实现。**

##### 一、文件描述符

在UNIX操作系统中，所有的外围设备（包括键盘和显示器）都被看作是文件系统中的文件，因此所有的输入/输出都要通过读文件或写文件完成。也就是说，通过一个单一的接口就可以处理外围设备和程序之间的所有通信。

通常情况下，在读或写文件之前，必须先将这个意图通知系统，该过程称为 **打开文件**。如果是写一个文件，则可能需要先创建文件，也可能需要丢弃该文件中原先以存在的内容。系统检查你的权力，如果一切正常，操作系统将向程序返回一个小的非负整数，该整数称为**文件描述符**。

**任何时候对文件的输入/输出都是通过文件描述符标识文件，而不是通过文件名标识文件。**（文件描述符类似与标准库中的文件指针或MS-DOS中的文件句柄。）系统负责维护已打开的文件所有信息，用户程序只能通过文件描述符引用文件。

因为大多数的输入/输出是通过键盘和显示器来实现的，为了方便起见，UNIX对此做了特别的安排。当命令解释程序（即“shell”）运行一个程序的时候，它将打开3个文件，对应的文件描述符分别为0、1、2，依次表示标准输入、标准输出和标准错误。如果程序从文件0中读，对1和2进行写，就可以进行输入/输出而不必关心打开文件的问题。

程序的使用者可通过 < 和 > 重定向程序的I/O：
```
prog <输入文件名 >输出文件名
```
这种情况下，shell把文件描述 0 和 1 的默认赋值改变为指定的文件。通常，文件描述2仍与显示器相关联，这样，出错信息会输出到显示器上。与管道相关的输入/输出也有类似的特性。**在任何情况下，文件赋值的改变都不是由程序完成的，而是由shell完成的。只要程序使用文件0作为输入，文件1和2作为输出，它就不会知道程序的输入从哪里来，并输出到哪里去。**

##### 二、低级I/O——read和write

输入与输出是通过read和write系统调用实现的。在C语言程序中，可以通过函数read和write访问这两个系统调用。在这两个函数中，第一个参数是文件描述符，第二个参数是程序中存放读或写的数据的字符数组，第三个参数是要传输的字节数。

```c
int n_read = read(int fd, char *buf, int n);
int n_written = write(int fd, char *buf, int n);
```
每个调用返回实际传输的字符数。在读文件时，函数的返回值可能小于请求的字节数。如果返回值为0，则表示已到达文件的结尾；如果返回值为-1，则表示发生来某种错误。在写文件时，返回值是实际写入的字节数。如果返回值与请求写入的字节数不相等，则说明发生了错误。

系统调用的函数原型集中放在一个头文件syscalls.h中。

##### 三、open、create、close和unlink

除了默认的标准输入、标准输出和标准错误文件外，其他文件都必须在读或写之前显式地打开。系统open和create用于实现该功能。

（1）**open与之前讨论的fopen很相似，不同的是，前者返回一个文件描述符，它仅仅是一个int类型的数值，而后者返回一个文件指针**。如果发生错误，open将返回-1。

```c
int open(char *name, int flags, int perms);
```
与 fopen一样，参数name是一个包含文件名的字符串。第二个参数flags是一个int类型的值，它说明以何种方式打开文件，主要的几个值如下所示：

- O_RDONLY——以只读方式打开文件
- O_WRONLY——以只写的方式打开文件
- O_RDWR——以读写方式打开文件

在System V UNIX系统中，这些常量在头文件<fcntl.h>中定义，而Berkeley(BSD)版本中则在<sys/file.h>中定义。
open的参数perms值代码权限信息，一般写0，可以使用下列语句打开一个文件以执行读操作： 

```c
int fd;
fd = open(name, O_RDONLY, 0);
```
**如果用open打开一个不存在的文件，则将导致错误**。

（2）**create系统调用创建新文件或覆盖已有的旧文件**，如下所示：

```c
int create(char *name, int perms);
fd = create(name, perms);
```
如果create成功地创建了文件，它将返回一个文件描述符，否则返回-1。如果此文件已存在，create将把该文件的长度截断为0，从而丢弃原先已有的内容。使用create创建一个已存在的文件不会导致错误。

如果要创建的文件不存在，则create用参数perms指定的权限创建文件。在UNIX文件系统中，每个文件对应一个9比特的权限信息，它们分别控制文件的所有者、所有者组和其他成员对文件的读、写和执行访问。因此，通过一个3位的八进制数就可方便说明不同的权限，例如，0755说明文件所有者可以对它进行读、写和执行操作，而所有者组和其他成员只能进行读和执行操作。

**一个程序同时打开的文件数是有限制的（通常为20）。相应地，如果一个程序要同时处理许多文件，那么它必须重用文件描述符。**

（3）**函数close(int fd) 用来断开文件描述符和已打开文件之间的连接，并释放此文件描述符，已供其他文件使用**。close函数与标准库中的fclose函数相对应，但它不需要清洗flush缓冲区。如果程序通过exit函数退出或从主程序中返回，所有打开的文件将被关闭。

（4）**函数unlink(char *name) 将文件name从文件系统中删除，它对应于标准库函数remove**。

##### 四、随机访问——lseek

输入/输出通常是顺序进行的：每次调用read和write进行读写的位置紧跟着前一次操作的位置之后。有时候需要已任意顺序访问文件，系统调用lseek可以在文件中 **任意移动位置而不实际读写任何数据**。

```c
long lseek(int fd, long offset, int origin);
```
将文件描述符为fd的文件的当前位置设置为offset，其中offset是相对于origin指定的位置而言的。随后进行的读写操作将从此位置开始。**origin的值可以为0、1 或 2**，分别用于指定  **offset  从文件开始、从当前位置或从文件结束处开始** 算起。

例如，为了向一个文件的尾部添加内容，则在写操作之前必须使用下列系统调用找到文件的末尾：

```c
lseek(fd, 0L, 2);
```
若要返回文件的开始处，则可以使用下列调用：
```c
lseek(fd, 0L, 0);
```

##### 五、实例——fopen和getc函数的实现

标准库函数fopen 和getc底层还是通过系统调用实现的。

##### 六、实例——目录列表

命令 ls

##### 七、实例——存储分配程序

malloc 和 free