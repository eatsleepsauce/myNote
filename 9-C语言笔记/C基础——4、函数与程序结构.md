#### 函数与程序结构

##### 一、函数

###### 1、函数的基本知识

函数的定义形式如下：

```
返回值类型 函数名(参数声明表)
{
    声明和语句
}
```
被调用函数通过return语句向调用者返回值，return语句的后面可以跟任何表达式： return 表达式;

调用函数可以忽略返回值。并且，return语句的后面也不一定需要表达式。

###### 2、返回非整型值的函数

对于非整型值的返回，函数必须声明返回值的类型，返回值的类型放在函数名之前。其次，调用函数也必须知道被调用函数返回的类型，常用方法是在调用函数中显式声明被调用函数，如：

```
main(){
    double atof(char[]);
    ...
}
```
函数声明与定义必须一致，如果函数与调用者都在同一个源文件中，并且类型不一致，编译器就会检测到该错误。但是，如果函数是单独编译的，这种不匹配的错误就无法检测出来。

##### 二、程序结构

**程序可以看成是 变量定义 和 函数定义 的集合**。函数之间的通信可以通过参数、函数返回值以及外部变量进行。函数在源文件中出现的次序可以是任意的。只要保证每一个函数不被分离到多个文件中，源程序就可以分成多个文件。

###### 1、外部变量

**C语言程序** 可以看成由 **一系列外部对象构成，这些外部对象可能是 变量 或 函数**。

**外部变量 定义在函数之外**，因此可以在许多函数中使用。由于C语言不允许在一个函数中定义其他函数，因此函数本身就是“外部的”。

**外部变量** 与 函数具有下列性质：通过同一个名字引用的所有外部变量（即使这种引用来自单独编译的不同函数）实际上都是引用同一个对象。

任何函数都可以通过名字访问一个外部变量，当然这个名字需要通过某种方式进行声明。

因为外部变量可以在全局范围内访问，这就为函数之间的数据交换提供来一种可以代替函数参数与返回值的方式。

###### 2、作用域规则

构成C语言程序的 函数 与 外部变量 可以分开进行编译（函数不能拆分到两个文件中）。一个程序可以存放在几个文件中，原先已编译过的函数可以从库中进行加载。

对于函数开头声明的 **自动变量（局部变量）**来说 ，其作用域就是声明该变量名的函数。

**外部变量 或 函数 的作用域** 从声明它的地方开始，到其所在的文件的末尾结束。

```
main(){...}
int sp = 0;
double val[100];

void push(double f){...}
double pop(void){...}
```
push与pop这两个函数中不需要进行任何声明就可以通过名字访问变量sp与val，但是这两个变量不能直接在main函数中使用，push与pop函数也不能直接在main函数中使用。

如果要在外部变量定义之前使用该变量，或者外部变量的定义与变量的使用不在同一个源文件中，则必须在相应的变量声明中强制性地使用关键字 extern。（外部变量的声明与定义严格区分开来很重要。变量声明用于说明变量的属性——主要是变量的类型，而变量定义除此意外还将引起存储器的分配）。

```
extern int sp;
extern double val[];
```
外部变量的初始化只能出现在其定义中。

###### 3、头文件

如果程序的各组成部分很长，将程序分割到若干个源文件中是很有必要的（分割成多个文件，主要是考虑在实际的程序中它们分别来自单独编译的库）。
假设一个分割场景：

将主函数main单独放在文件main.c中；

将push与pop函数及它们使用的外部变量放在第二个文件stack.c中；

将getop函数放在第三个文件getop.c；

将getch与ungetch函数放在第四个文件getch.c中。

考虑 定义 与 声明 在这些文件之间的共享问题。我们尽可能把共享的部分集中在一起，我们把这些公共的部分放在头文件 calc.h 中，在需要使用该头文件时通过\#include指令将它包含进来。程序的形式如下所示：

```c
/*calc.h*/
#define NUMBER '0'
void push(double);
double pop(void);
int getop(char[]);
int getch(void);
void ungetch(int);

/*main.c*/
#include <stdio.h>
#include <stdlib.h>
#include "calc.h"
#define MAXOP 100
 main(){
    ...
}

/*getop.c*/
#include <stdio.h>
#include <ctype.h>
#include "calc.h"
getop(){
    ...
}

/*stack.c*/
#include <stdio.h>
#include "calc.h"
#define MAXVAL 100
int sp = 0;
double val[MAXVAL];
void push(double){
    ...
}
double pop(void){
    ...
}

/*getch.c*/
#include <stdio.h>
#define BUFSIZE 100
char buf[BUFSIZE];
int bufp = 0;
int getch(void){
    ...
}
void ungetch(int){
    ...
}
```
###### 4、静态变量

用 static 声明限定的外部变量与函数，static 可以将其后声明的对象 的作用域 限定为 被编译文件的剩余部分。(通过static限定外部对象，可以达到隐藏外部对象的目的)。

static也可用于声明内部变量。static类型的内部变量同自动变量一样，是某个特定函数的局部变量，只能在该函数中使用，但它与自动变量不同的是，不管其所在的函数是否被调用，它一直存在，而不像自动变量那样，随着所在函数的被调用和退出而存在和消失。（static类型的内部变量是一种只能在某个特定函数中使用但一直占据存储空间但变量。）

###### 5、寄存器变量

register声明告诉编译器，它所声明但变量在程序中使用频率较高。其思想是，将register变量放在机器的寄存器中，这样可以使程序更小、执行速度更快。但编译器可以忽略此选项。
register 声明的形式如下所示：

```c
register int x;
register char c;
```
注意点：无论寄存器变量实际上是否存放在寄存器中，它的地址都是不能访问的。在不同的机器中，对寄存器变量的数目和类型的具体限制也是不同的。

###### 6、程序块结构

在函数中可以以程序块结构的形式定义变量，变量的声明（包括初始化）除了可以紧跟在函数开始的花括号之后，还可以紧跟在任何其他标识复合语句开始的左花括号之后。

```
if(n > 0){
    int i;
    ...
}
```
这种方式声明的变量可以隐藏程序块外与之同名的变量，它们之间没有任何关系，并在与左花括号匹配的右花括号出现之前一直存在。

**每次进入程序块时，在程序块内声明以及初始化的自动变量都将被初始化。静态变量只在第一次进入程序块的时被初始化一次。**

###### 7、变量初始化

定义变量时，可以在变量名后紧跟着一个等号和一个表达式来初始化变量：

```c
int x = 1;
char squato = '\'';
long day = 1000L * 60L * 60L * 24L;
```
- 在不进行显式初始化的情况下，外部变量和静态变量都将被初始化为0，而自动变量和寄存器变量的初值没有定义（即初值为无用的信息）。
- 对于外部变量与静态变量来说，初始化表达式必须是常量表达式，且初始化一次（从概念上讲是程序开始执行前进行初始化）。
- 对于自动变量与寄存器变量来说，则在每次进入函数或程序块时都将初始化。
- 对于自动变量与寄存器变量来说，初始化表达式可以不是常量表达式：表达式中可以包含任意在此表达式之前已定义的值，包括函数调用。

**数组的初始化** 是在声明的后面紧跟一个初始化表达式列表，初始化表达式列表用花括号括起来，各初始化表达式之间通过逗号分隔。

```c
int days[] = {31, 28, 31, 30}
```
省略数组长度时，编译器将花括号中的表达式的个数作为数组长度。如果初始化表达式的个数比数组元素少，则对 **外部变量**、**静态变量** 和 **自动变量** 来说，没有初始化表达式的元素将被初始化为0。如果初始化表达式的个数比数组元素多，则是错误的。

**字符串数组的初始化** 比较特殊：可以用一个字符串来代替花括号括起来并用逗号分隔的初始化表达式序列。

```
char pattern[] = "ould";
```
等同于
```
char pattern[] = {'o', 'u', 'l', 'd', '\0'};
```

###### 8、C预处理器

C语言通过预处理器提供来一些语言功能。从概念上讲，预处理器是编译过程中单独执行的第一个步骤。两个最常见的预处理器指令是\#include指令（用于在编译期间把指定的文件的内容包含进当前文件中）和\#define指令（用于以任意字符序列替代一个标记）。

**（1）文件包含**
文件包含指令（即\#include指令）使得处理大量的\#define指令以及声明更加方便。

在源文件中，任何形如: \#include "文件名" 或 \#include <文件名>的行都将替换为由该文件名指定的文件的内容。

- 如果文件名用引号引起来，则在源文件所在位置查找该文件；

- 如果在该位置没有找到文件，或者如果文件名用尖括号括起来，则根据相应的规则查找该文件，这个规则同具体的实现有关。**被包含的文件本身也可包含\#include指令**。

源文件的开始处通常都会有多个\#include指令，它们用以 **包含常见的\#define语句 和 extern声明，或者 从头文件中访问库函数的函数原型声明**。

\#include指令是将所有声明捆绑在一起的较好的方法。它保证所有的源文件都具有相同的定义与变量声明，这样可以避免出现一些不必要的错误。

**（2）宏替换**
宏定义的形式如下：

```
#define 名字 替换文本
```
后续所有出现名字记号的地方都将被替换为替换文本。**可以通过\#undef 名字 指令来取消名字的宏定义，这样做可以保证后续的不是宏调用。**

- \#define指令占一行，替换文本是\#define指令行尾的所有剩余部分内容。但也可以把一个较长宏定义分成若干行，这时需要在待续的行末尾加上一个反斜杠符\\。
- \#define指令定义的名字作用域从其定义点开始，到被编译的源文件末尾处结束。
- 宏定义中也可以使用前面出现的宏定义。
- 宏替换只对记号进行，对括在引号中的字符串不起作用。替换文本可以是任意的，例如：

```c
#define forever for(;;)//无限循环
#define max(A,B) ((A) > (B)) ? (A) : (B)
```


\# 和 \##的使用方法，示例：

```c
#define dprint(expr)  printf(#expr " =%g\n", expr)
```
使用语句 dprint(x/y); 调用该宏时，该宏将被扩展为 printf("x/y" " =%g\n", x/y);

形式参数不能用带引号的字符串替换，但是如果在替换文本中参数名以\#作为前缀，则结果将被扩展为由实际参数替换该参数的带引号的字符串。

预处理运算符 \## 为宏扩展提供了一种连接实际参数的手段。如果替换文本中的参数与 \##相邻，则该参数将被实际参数替换，\##与前后的空白字符将被删除，并对替换后的结果重新扫描。例如，

```c
#define paste(front, back) front ## back
```
宏调用 paste(name,1) 的结果将创建记号 name1。

**（3）条件包含**
可以使用条件语句对预处理本身进行控制，这种条件语句的值是在预处理执行的过程中进行计算。

\#if 语句对其中的常量整型表达式（其中不能包含sizeof、类型转换运算符或enum常量）进行求值，若该表达式的值不等于0，则包含其后的各行，知道遇到\#endif、\#elif或者\#else语句为止。在\#if语句中可以使用表达式defined(名字)。
例如，为了保证hdr.h文件的内容只被包含一次，则可以用下列形式：

```c
#if !defined(HDR)
#define HDR .../*HDR的内容*/
#endif
```
再比如，下面这个例子，根据系统变量SYSTEM的值确定包含哪个版本的头文件：
```c
#if SYSTEM == SYSV
    #define HDR "sysv.h"
#elif SYSTEM == BSD
    #define HDR "bsd.h"
#elif SYSTEM == MSDOS
    #define HDR "msdos.h"
#else
    #define HDR "default.h"
#endif
#include HDR
```
C语言专门定义了两个预处理语句\#ifdef 与 \#ifndef，它们用来测试某个名字是否已经定义，所以第一个例子可以用以下形式：
```c
#ifndef HDR
#define HDR .../*HDR的内容*/
#endif
```

