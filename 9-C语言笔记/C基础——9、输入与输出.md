#### 输入与输出

标准库实现了简单的文本输入/输出模式。文本流由一系列行组成，每一行的结尾是一个换行符。如果系统没有遵循这种模式，则标准库将通过一些措施使得该系统适应这种模式。例如，标准库可以在输入端将回车符和换页符都转换为换行符，而在输出端进行反向转换。

##### 一、getchar/putchar

最简单但输入机制是使用getchar函数从标准输入中（一般为键盘）一次读取一个字符：
```c
int getchar(void);
```
getchar 函数在每次调用是返回下一个输入字符。若遇到文件结尾，则返回EOF。符号常量EOF在头文件<stdio.h>中定义，其值一般为-1，但程序中应该使用EOF来测试文件是否结束，这样才能保证程序同EOF的特定值无关。
在许多环境中，**可以使用  \<  来实现输入重定向**，例如将标准输入替换为文件输入：如果程序prog中使用来函数getchar函数，则命令行

```
prog < infile
```
将使得程序prog从输入文件infile中读取字符。程序prog本身并不在意输入方式的改变，并且，“\< infile”也并不包含在argv的命令行参数中（此处不清楚可参见，指针与数组模块的命令行参数）。
如果输入通过管道机制来自另一个程序，比如，在某些系统中，下列命令行：

```
otherprog | prog
```
将运行两个程序otherprog 和 prog，并将程序 otherprog 的标准输出通过管道重定向到程序prog的输入上。

函数
```
int putchar(int)
```
用于输出数据。putchar(c) 将字符c送至标准输出上，在默认情况下，标准输出为屏幕显示。如果没有发生错误，则函数putchar将返回输出的字符；如果发生来错误，则返回 EOF。
同样，通常情况下，也可以使用“ \>输出文件名 ”的格式将输出重定向到某个文件中。例如，如果程序prog调用了函数putchar，那么命令行

```
prog > 输出文件名
```

##### 二、格式化输出——printf函数

输出函数printf将内部数值转换为字符的形式。

```c
int printf(char *format, arg1, arg2, ...)
```
函数printf 在输出格式format的控制下，将其参数进行转换与格式化，并在标准输出设备上打印出来。它的返回值为打印的字符数。

格式字符串包含两种类型的对象：**普通字符** 和 **转换说明**。在输出时，普通字符将原样不动地复制到输出流中，而转换说明并不直接输出到输出流中，而是用于控制 printf 中参数的转换和打印。

**转换说明符** 都是一个百分号字符（%）开始，并以一个转换字符结束。在字符%和转换字符中间可能依次包含下列组成部分：

- 负号，用于指定被转换的参数按照左对齐的形式输出。

- 数，用于指定最小字段宽度。转换后的参数将打印不小于最小宽度的字段。如果有必要，字段左边（如果使用左对齐的方式，则为右边）多余的字符位置用空格填充以保证最小宽度。

- 小数点，用于将字段宽度和精度分开。

- 数（小数点后面的），用于指定精度，即指定 **字符串中要打印的最大字符数**、**浮点数小数点后的位数**、**整型最少输出的数字数目**。

- 字母h或l，字母h表示将整数作为short类型打印，字母l表示将整数作为long类型打印。

  

**pringf函数基本的转换说明如下：**
<img src="https://liuyang-picbed.oss-cn-shanghai.aliyuncs.com/2020-12-08-145760.png" alt="转换说明.png" style="zoom:67%;" />

下面示例，打印 “hello, world” (12个字符)说明了不同的转换说明产生的不同结果（添加冒号是为了更清晰地表示）：
```c
:%s:                  :hello, world:
:%10s:                :hello, world:
:%.10s:               :hello, wor:
:%-10s:               :hello, world:
:%.15s:               :hello, world:
:%-15s:               :hello, world   :
:%15.10s:             :     hello, wor:
:%-15.10s:            :hello, wor     :
```

在转换说明中，宽度或精度可以用星号 \* 表示，这时，宽度或精度的值通过转换下一参数（必须为int类型）来计算。例如，为了从字符串s中打印最多max个字符，可以使用下列语句：
```c
printf("%.*s", mas, s);
```

sprintf 函数和 printf 函数形同，但它将输出保存到一个字符中（printf默认标准输出）：
```c
int sprintf(char *string, char *format, arg1, arg2, ...)
```
函数printf的参数是可变长的，声明形式如下：
```c
int printf(char *fmt, ...)
```
省略号表示参数表中的数量和类型是可变的。

##### 三、格式化输入——scanf函数

输入函数scanf对应于输出函数printf，它在与后者相反的方向上提供同样的转换功能。具有变长参数表的函数scanf的声明形式如下：

```c
int scanf(char *format, ...)
```
scanf函数 从标准输入中读取字符序列，按照 format 中的格式说明对字符序列进行解释，并把结果保存到其余的参数中。

除格式参数 format，其他所有参数都必须是指针，用于指定经格式转换后的相应输入保存的位置。

当scanf函数扫描完其个格式串，或则碰到某些输入无法与格式控制说明匹配的情况时，该函数将终止，同时，成功匹配并赋值的输入项的个数将作为函数返回，所以该函数的返回值可以用来确定已匹配的输入个数。如果到底文件的结尾，该函数将返回EOF。

函数sscanf也是输入函数，它用于从一个字符串（而不是标准输入）中读取字符序列：
```c
int sscanf(char *string, char *format, arg1,arg2, ...)
```
它按照格式参数format中规定的格式扫描字符串string，并把结构分别保存到arg1，arg2，... 这些参数也必须是指针。

**格式串** 通常都包含转换说明，用于控制输入的转换，格式串可能包含下列部分：

- 空格或制表符，在处理过程中将被忽略。
- 普通字符串（不包括%），用于匹配输入流中下一个**非空白符字符**。
- 转换说明，依次由一个%、一个可选的赋值禁止字符\*、一个可选的数值（指定最大字段的宽度）、一个可选的h、l或L字符（指定目标对象的宽度）以及一个转换字符组成。

**转换说明** 控制下一个输入字段的转换。一般来说，转换结果存放在相应的参数指向的变量中。但是，如果转换说明中有赋值禁止符 \*，则跳过该输入字段，不进行赋值。
**输入字段** 定义为一个不包含空白符的字符串，其 **边界定义为到下一个空白符或达到指定的字段宽度**（空白符包括空格符、横向制表符、换行符、回车符、纵向制表符以及换页符）。

转换说明，在百度百科上说得比较精确，可以参见[scanf函数](https://baike.baidu.com/item/scanf/10773316)

##### 四、文件访问

在读写一个文件之前，必须通过 **库函数fopen** 打开文件，并返回一个随后可以用于文件读写操作的指针。

**文件指针**，它指向一个包含文件信息的结构，这些信息包括：缓冲区的位置、缓冲区中当前字符的位置、文件的读或写状态、是否出错或是否已经到达文件结尾等等。用户不必关心这些细节，因为\<stdio.h\>中已经定义了一个包含这些信息的结构FILE。在程序中只需要按照下列方式声明一个指针即可：

```c
FILE *fp;
FILE *fopen(char *name, char *mode);
```
fp是一个指向结构的FILE指针，注意，FILE像int类型一样是一个类型名，而不是结构标记。它是通过typedef定义的。
在程序中可以这样调用foper函数：

```c
fp = fopen(name, mode);
```
fopen的第一个参数是一个字符串，它包含文件名。第二个参数是访问模式，也是一个字符串，用于指定文本的使用方式。允许的模式包括：读（“r”）、写（“w”）及追加（“a”）。某些系统还区分文本文件和二进制文件，对后者的访问需要在模式字符串中增加字符“b”。

如果打开一个不存在的文件用于写或追加，该文件将被创建（如果可能的话）。当以写方式打开一个已存在的文件时，该文件原来的内容将被覆盖。但是，如果以追加方式打开一个文件，则该文件原来的内容将保持不变。读一个不存在的文件或导致错误，其他一些操作也可能导致错误，比如试图读取一个无读取权限的文件。如果发生错误，fopen将返回NULL。

文件被打开后，就需要考虑采用哪种方法对文件进行读写。有多种方法可供考虑，其中，getc 和 putc 函数最简单。

getc 从文件中返回下一个字符，它需要知道文件指针，以确定对哪个文件执行操作：

```c
int getc(FILE *fp);
```
getc 函数返回 fp 指向的输入流中的下一个字符。如果到达文件尾或出现错误，该函数将返回EOF。

putc是一个输入函数，如下所示：

```c
int putc(int c, FILE *fp);
```
该函数将字符c写入到fp指向的文件中，并返回写入的字符。如果发生错误，则返回EOF。

**启动一个C语言程序时，操作系统环境负责打开3个文件，并将这3个文件的指针提供给该程序。这3个文件分别是标准输入、标准输出和标准错误，相应的文件指针分别为stdin、stdout和stderr，它们在\<stdio.h\>中声明。**在大多数环境中，stdin指向键盘，而stdout和stderr指向显示器。

getchar和putchar函数可以通过 getc、putc、stdin及stdout 定义如下：

```c
#define getchar() getc(stdin)
#define putchar(c) putc((c), stdout)
```

对于文件的格式化输入或输出，可以使用函数fscanf和fprintf。它们与scanf和printf函数的区别仅仅在于它们的第一个参数是指向所需读写的文件的指针，第二个参数是格式串。如下所示：
```c
int fscanf(FILE *fp, char *format, ...)
int fprintf(FILE *fp, char *format, ...)
```

**函数 fclose**，执行和fopen相反的操作，**它断开有fopen函数建立的文件指针和外部名之间的连接，并释放文件指针以供其他文件使用**。因为大多数操作系统都限制了一个程序可以同时打开的文件数，所以，当文件执行不需要时就释放。对输出文件fclose还有另外一个原因：它将把缓冲区中的putc函数正在收集的输出写到文件中。

```c
int fclose(FILE *fp)
```
##### 五、错误处理——stderr和exit

标准错误文件sterr就是程序打开时，被打开的三个文件之一。即使对标准输出进行了重定向，写到stderr中的输出通常也会显示在屏幕上。

```c
...
if(ferror(stdout)){
    fprintf(stderr, "%s: error writing stout\n", prog);
    exit(2);
}
...
```
**fprintf函数** 产生的诊断信息输出到stderr上，因此诊断信息将会显示在屏幕上，而不是仅仅输出到管道或输出文件中。

**标准库函数exit**，当该函数被调用时，它将终止调用程序的执行。任何调用该程序的进程都可以获取exit的参数值。按照惯例，返回值0表示一切正常，而非0返回值通常表示出现了异常情况。exit为每个已打开的输出文件调用fclose函数，以将缓冲区中的所有输出写到相应的文件中。

主程序main中，语句return exp 等价于exit(expr)。但是，使用函数exit有一个优点，它可以从其他函数中调用。

**ferror 和函数 int feof(FILE*) 类似**，如果指定的文件到达文件尾，它将返回一个非0值。

##### 六、行输入和行输出

标准库提供一个输入函数fgets

```c
char *fgets(char *line, int maxline, FILE *fp)
```
fgets函数从fp指向的文件中读取下一个输入行（包括换行符），并将它放在字符数组line中，它最多可读取maxline - 1个字符。读取的行将以'\0'结尾保存到数组中。通常情况下，fgets返回line，但如果遇到了文件结尾或发生了错误，则返回NULL。

输出函数fputs将一个字符串（不需要包含换行符）写入到一个文件中：
```c
int fputs(char *line, FILE *fp)
```
如果发生错误，该函数将返回EOF，否则返回一个非负值。

**库函数 gets 和 puts 的功能与 fgets 和 fputs 函数 **类似，但它们是对 stdin 和 stdout 进行操作。gets函数在读取字符串是将删除结尾的换行符（'\n'）,而puts函数在写入字符串时将在结尾添加一个换行符。









