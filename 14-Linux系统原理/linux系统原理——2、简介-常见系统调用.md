#### 常见系统调用

系统调用决定了一个操作系统好不好用、功能全不全。**命令 strace，常用来跟踪进程执行时系统调用和所接收的信号**。

###### **1、进程管理**

**创建进程的系统调用叫fork**，在linux里创建一个新的进程，需要一个老的进程调用fork来实现，老的进程叫 **父进程（Parent Process）**，新的进程叫做 **子进程（Child Process）**。操作系统启动的时候先创建一个所有用户进程的祖宗进程。

当父进程调用fork创建进程的时候，子进程将各个子系统为父进程创建的数据结构也全部拷贝了一份，甚至代码也拷贝过来了，如果不进行特殊处理，父子进程都是相同的代码执行下去，意义也就不大了。

对于fork系统调用的返回值，如果当前进程是子进程就返回0；如果当前进程是父进程就返回子进程的进程号。有了返回值后就可以继续区分，如果是父进程还接着做原来的事情，如果是子进程就请求另一个**系统调用 execve** 来**执行另一个程序**，这个时候子进程和父进程就彻底分开了。

（注：既然fork是复制，就说明父进程和子进程在用户态的代码段是一模一样的，如果fork这个系统调用后面的语句都是A，则无论是父进程，还是子进程都是接下来要执行A的。好在fork是一个系统调用，刚从内核返回的时候，由于内核是能够区分父进程和子进程的，因而用户态的程序代码里面，往往通过这个返回值来判断自己是父进程还是子进程，因为子进程如果不判断一下，是不知道自己是子进程的）

父进程要关心子进程的运行情况，可以通过 **系统调用waitpid** ，父进程将子进程的进程号作为参数传给它，这样父进程就知道子进程运行完了没有，成功与否。

###### **2、内存管理**

在操作系统中，每个进程都有自己的内存，互相之间不干扰，有 **独立的进程内存空间**。进程的内部空间，放进程代码的地方叫做 **代码段（Code Segment）**，放进程运行中产生的数据的地方叫做 **数据段（Data Segment）**。（局部变量的部分，在当前函数执行的时候起作用，当进入另一个函数的时，这个变量就是释放了。**动态分配的，会长时间保存的，指明才销毁的，这部分称堆heap**）

只有进程要去使用部分内存的时候，才会使用内存管理的系统调用来登记，这还没有真的就对应到了物理内存。只有真的写入数据，发现没有对应物理内存，才会触发一个中断，分配物理内存。

**系统调用 brk**，分配内存数量比较小的时候使用，会和原来的堆数据连在一起。

**系统调用 mmap**，当分配的内存数量比较大的时候，使用mmap会重新划分一块区域。

###### **3、文件管理**

Linux里有一个特点，那就是 **一切皆文件**。

（1）启动一个进程，需要一个程序文件，这个是二进制文件。

（2）启动的时候，要加载一些配置文件，如 yml、properties等，这些是文本文件。

（3）打印日志到控台上，在命令行上打印出来，这也是一个文件，标准输出文件stout文件。

（4）进入的输出可以作为另一个进程的输入，这种方式称为管道，管道也是一个文件。

（5）进程可以通过网络和其他进程通信，建立的socket也是一个文件。

（6）进程需要访问的外部设备，设备也是一个文件。

（7）文件被存在一个文件夹里面，文件夹其实也是一个文件。

（8）进程运行起来，想看到进程的运行情况，会在/proc下面有对应的进程号，还是一系列文件。

每个文件，linux都会分配一个 **文件描述符（File Descriptor）**，这是一个整数，有了文件描述符，我们就可以使用系统调用。

**文件相关的系统调用：**

（1）对于已有的文件，可以使用 **open打开** 这个文件， **close关闭** 这个文件。

（2）对于没有的文件，可以使用 **creat创建** 文件。

（3）打开文件后，可以使用 **lseek跳到** 文件的某个位置。

（4）可以对文件的内容进行读写，**read读，write写**。

###### **4、信号处理**

操作系统收到信号后可以觉得如何处理这些信号，对于一些不严重的信号，可以忽略，但是想GIGKILL（用于终止一个进程的信号）和GIGSTOP（用于中止一个进程的信号）是不能忽略的。可以执行该信号的默认动作。每种信号都定义了默认的动作，例如硬件故障，默认中止。

也可以提供信号处理函数，**使用sigaction系统调用，注册一个信号处理函数**。

常见信号：

（1）在执行一个程序的时候，在键盘输入CTRL + C，这就是中断信号，正在执行的命令就会中止退出

（2）非法访问内存

（3）硬件故障

（4）用户进程通过kill函数，将一个用户信号发送给另一个进程

###### **5、进程间通信**

不需要很长的数据，这种方式叫 **消息队列（Message Queue）**，消息队列在内核里面，可以通过 **msgget创建** 一个新的队列， **msgsnd将消息发送到消息队列**，消息接收方可以使用 **msgrcv从队列中取消息**。

交互信息比较大，使用 **共享内存** 方式，通过 **shmget创建一个共享内存块**，通过 **shmat将共享内存映射到自己的内存空间**，然后就可以读写了。

解决共享竞争问题，可以通过信号量Semaphore机制，对于只允许一个人访问情况，设置信号量为1（由支持多少人同时访问决定），当一个人访问的时候先调用 **sem_wait**，如果没有占用这个信号量就可以访问了，其他人调用sem_wait必须等上一个人访问完了才行。上一个人访问完成后，调用 **sem_post** 将信号量释放，下个人才可以访问。

###### **6、网络通信**

Linux内核里由对网络协议栈的实现，网络服务是通过Socket来提供服务的，Socket也是一个文件，也有文件描述符，可以通过读写函数进行通信。

###### **7、可以通过系统源码查看其它系统调用**

源码地址：[https://www.kernel.org](https://www.kernel.org)

###### **8、标准库**

Glibc 是 Linux 下使用的开源的标准 C 库，它是 GNU 发布的 libc 库。Glibc 为程序员提供丰富的 API，除了例如字符串处理、数学运算等用户态服务之外，最重要的是封装了操作系统提供的系统服务，即 **系统调用的封装**。

![Linux系统调用.jpg](https://liuyang-picbed.oss-cn-shanghai.aliyuncs.com/img/2020-12-08-145739.jpg)