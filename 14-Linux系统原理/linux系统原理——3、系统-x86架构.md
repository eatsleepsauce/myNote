#### x86架构

##### 一、计算机逻辑图

<img src="https://liuyang-picbed.oss-cn-shanghai.aliyuncs.com/2020-12-08-145719.jpg" alt="计算机逻辑图.jpeg" style="zoom: 50%;" />

CPU（Central Processing Unit，中央处理器）不是单纯的一块，它包括三个部分，运算单元、数据单元和控制单元。

**运算单元 **只管算，例如做加法、做位移等等。但是，它不知道应该算哪些数据，运算结果应该放在哪里。

**数据单元** 包括 CPU 内部的缓存和寄存器组，空间很小，但是速度飞快，可以暂时存放数据和运算结果（运算单元计算的数据如果每次都要经过总线，到内存里面现拿，这样就太慢了，所以就有了数据单元）。

**控制单元** 是一个统一的指挥中心，它可以获得下一条指令，然后执行这条指令。这个指令会指导运算单元取出数据单元中的某几个数据，计算出个结果，然后放在数据单元的某个地方（有了放数据的地方，也有了算的地方，还需要有个指挥到底做什么运算的地方，这就是控制单元。）。

##### 二、CPU和内存如何配合

<img src="https://liuyang-picbed.oss-cn-shanghai.aliyuncs.com/2020-12-08-145721.jpg" alt="CPU与内存.jpeg" style="zoom:67%;" />

**程序运行的过程中要操作的数据和产生的计算结果，都会放在数据段里面**。CPU怎么执行这些程序，操作这些数据，产生一些结果，并写回内存？

（1）CPU的控制单元里面由一个 **指令指针寄存器**，里面存放的是下一条指令在内存中的地址。

（2）控制单元会不停地将代码段的指令拿进来，存放到 **指令寄存器** 中。

（3）指令分为两部分，一部分是做什么操作，例如加法还是位移；一部分是操作哪些数据。指令执行的时候，就要把第一部分交给 **运算单元**，第二部分交给 **数据单元**。

（4）数据单元根据数据地址，将数据从数据段里读到 **数据寄存器** 里面，就可以参与运算了，运算单元做完运算，产生的结果会暂存在数据单元的数据寄存器里，最终会有指令将数据写回到内存中。

CPU和内存来来回回传数据，靠的是 **总线**。总线主要由两类，一个是 **地址总线**，另一个是 **数据总线**，地址总线的位数决定了能访问的地址范围（如：地址总线是两位，则CPU只能访问00 01 10 11四个位置）。数据总线的位数决定了一次能拿多少个数据进来。

##### 三、8086原理

很多CPU都是从英特尔8086这款型号CPU开端的，所以统称为x86架构，现在CPU的数据总线和地址总线越来越宽，处理能力越来越强。8086 处理器虽然已经很老了，但是现在操作系统中的很多特性都和它有关，并且一直保持兼容。

<img src="https://liuyang-picbed.oss-cn-shanghai.aliyuncs.com/2020-12-08-145722.jpg" alt="型号和总线.jpg" style="zoom:67%;" />



<img src="https://liuyang-picbed.oss-cn-shanghai.aliyuncs.com/2020-12-08-145723.jpg" alt="8086CPU.jpeg" style="zoom:67%;" />

**数据单元：**

8086处理器内部有8个16位通用寄存器，也就是CPU的数据单元，分别是AX、BX、CX、DX、SP、BP、SI、DI。这些寄存器主要用于在计算过程中暂存数据。其中AX、BX、CX、DX可以分成两个8位的寄存器来使用，分别是AH、AL、BH、BL、CH、CL、DH、DL，H就是high（高位），L就是low（低位）。

**控制单元：**

**IP寄存器就是指令指针寄存器**（Instruction Pointer Register），指向代码段中下一条指令的位置。CPU会根据它来不断地将指令从内存的代码段中加载到CPU到指令队列中，然后交给运算单元去执行。

每个进程都分代码段和数据段，为了指向不同进程的地址空间，有四个16位的段寄存器，分别是CS、DS、SS、ES。

CS就是**代码段寄存器**（Code Segment Register），通过它可以找到代码在内存中的位置；DS是**数据段的寄存器**，通过它可以找到数据在内存中的位置。

在CS和DS中都存放着一个段的起始地址。代码段的偏移量在IP寄存器中，数据段的偏移量会放在通用寄存器中。

8086CPU中CS和DS都是16位的，IP寄存器和通用寄存器都是16位的，但是8086的地址总线是20位的。为了凑够20位，就是使用 **起始地址*16 + 偏移量**，也就是把CS和DS中的值左移4位变成20位的，加上16位的偏移量，这样最终得到20位的地址。

由于地址总线只有20位，所以只能访问1M的空间地址。而一个段的大小因为偏移量是16位的，所以一个段的最大的大小是2^16=64k。

##### 四、32位处理器

在32位处理器中，有32根地址总线，可以访问4G的内存，使用原来的模式不行了，但是又不能完全抛弃原来的模式，因为这个架构是开放的，那么如何保持兼容呢？

<img src="https://liuyang-picbed.oss-cn-shanghai.aliyuncs.com/2020-12-08-145724.jpg" alt="32位寄存器扩展.jpeg" style="zoom:67%;" />

（1）通用寄存器16位扩展到32位，依然保留16位和8位的使用方式。（高16位不能分成两个8位使用的原因是因为程序没有基于高位开发的，所以不兼容）

（2）指向下一条指令的指令指针寄存器IP，扩展成32位的，同样也兼容16位的。

（3）改动比较大的是段寄存器（Segment Register），因为原来8086CPU没有使用16位做一个段的起始地址，而是使用了一个不上不下的20位地址。这样每次都要左移四位，也就意味着段的起始地址不能是任何一个地方，只能是整除16的地方。**所以32位CPU重新定义了 CS、SS、DS、ES，它们任然是16位的，但是不再是段的起始地址。段的起始地址放在内存的某个地方。这个地方是一个表格，表格中的一项项段描述符（Segment Descriptor）才是真正的段起始地址。而段寄存器里面保存的是在这个表格中的哪一项，称为 选择子（Selector）**。

<img src="https://liuyang-picbed.oss-cn-shanghai.aliyuncs.com/2020-12-08-145725.jpg" alt="32位CPU变化.jpeg" style="zoom:67%;" />

这样将从段寄存器直接拿到段起始地址，就变成了先间接地从段寄存器找到表格中的一项，再从表格中的一项中拿到段起始地址。这种获取段起始地址段方式就会很灵活了，当然为了快速拿到段的起始地址，段描述符会从内存中拿到CPU的描述符高速缓存器中。

在32位的系统架构下，将之前的模式称为 **实模式（Real Pattern）**，后一种模式称为 **保护模式（Protected Pattern）**。系统刚启动的时候，CPU是处于实模式的，这个时候和原来是兼容的，当需要更多内存的时候，可以遵循一定的规则进行一系列的操作，然后切换到保护模式，这样就能够用到32位CPU更强大的能力。