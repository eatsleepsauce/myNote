#### 抢占式调度

最常见的现象就是一个进程执行时间太长了，是时候切换到另一个进程了。

另外一个可能抢占的场景是当一个进程被唤醒的时候。

抢占的时机，真正的抢占还需要时机，也就是需要那么一个时刻，让正在运行中的进程有机会调用一下 schedule。不可能某个进程代码运行着，突然要去调用 schedule，代码里面不可能这么写，所以一定要规划几个时机，这个时机分为用户态和内核态。

**用户态的抢占时机：**

对于用户态的进程来讲，从系统调用中返回的那个时刻，是一个被抢占的时机。

对于用户态的进程来讲，从中断中返回的那个时刻，也是一个被抢占的时机。

**内核态的抢占时机：**

对内核态的执行中，被抢占的时机一般发生在 preempt_enable() 中。在内核态的执行中，有的操作是不能被中断的，所以在进行这些操作之前，总是先调用 preempt_disable() 关闭抢占，当再次打开的时候，就是一次内核态代码被抢占的机会。

在内核态也会遇到中断的情况，当中断返回的时候，返回的仍然是内核态。这个时候也是一个执行抢占的时机。



先记一个脑图，能力够了再补细节。

<img src="https://liuyang-picbed.oss-cn-shanghai.aliyuncs.com/img/93588d71abd7f007397979f0ba7def7f.png" alt="img" style="zoom:67%;" />