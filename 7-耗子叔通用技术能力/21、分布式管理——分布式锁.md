#### 分布式锁 Distributed Lock

在多线程情况下访问一些共享资源需要加锁，不然就会出现数据被写乱的问题。在分布式系统下，这样的问题也是一样的。只不过，我们需要一个分布式的锁服务。对于分布式的锁服务，一般可以用数据库 DB、Redis 和 ZooKeeper 等实现。不管怎么样，分布式的锁服务需要有以下几个特点。

- **安全性（Safety）**：在任意时刻，只有一个客户端可以获得锁（排他性）。
- **避免死锁**：客户端最终一定可以获得锁，即使锁住某个资源的客户端在释放锁之前崩溃或者网络不可达。
- **容错性**：只要锁服务集群中的大部分节点存活，Client 就可以进行加锁解锁操作。

##### 一、Redis的分布式锁服务

Redis的锁服务[官方的文档](https://redis.io/topics/distlock)

**对资源枷锁**：

```
SET resource_name my_random_value NX PX 30000
```

- SET NX 命令只会在key不存在的时候给key赋值，PX命令通知Redis保存这个key 3000ms。
- my_random_value 必须是全局唯一的值。这个随机数在释放锁时保证释放锁操作的安全性。
- PX 操作后面的参数代表的是这个 key 的存活时间，称作 **锁过期时间**。
- 当资源被锁定超过这个时间时，锁将自动释放。
- 获得锁的客户端如果没有在这个时间窗口内完成操作，就可能会有其他客户端获得锁，引起争用问题。

原理是，只有在某个 key 不存在的情况下才能设置（set）成功该 key。于是，这就可以让多个进程并发去设置同一个 key，只有一个进程能设置成功。而其它的进程因为之前有人把 key 设置成功了，而导致失败（也就是获得锁失败）。

**为申请成功的锁解锁：**

通过以下Lua脚本完成(保障了原子性)

```
if redis.call("get",KEYS[1]) == ARGV[1] then 
    return redis.call("del",KEYS[1]) 
else 
    return 0 
end
```

如果 key 对应的 value 一致，则删除这个 key。通过这个方式释放锁是为了避免 Client 释放了其他 Client 申请的锁。

关于 value 的生成，官方推荐从 /dev/urandom 中取 20 个 byte 作为随机数。或者采用更加简单的方式，例如使用 RC4 加密算法在 /dev/urandom 中得到一个种子（Seed），然后生成一个伪随机流。

也可以采用更简单的方法，使用时间戳 + 客户端编号的方式生成随机数。Redis 的官方文档说：“这种方式的安全性较差一些，但对于绝大多数的场景来说已经足够安全了”。

##### 二、分布式锁服务的一个问题

虽然 Redis 文档里说他们的分布式锁是没有问题的，但其实还是很有问题的。尤其是上面那个为了避免 Client 端把锁占住不释放，然后，Redis 在超时后把其释放掉。

<img src="https://liuyang-picbed.oss-cn-shanghai.aliyuncs.com/img/937d9975899662d90a96f4cd70580d89.png" alt="937d9975899662d90a96f4cd70580d89" style="zoom:80%;" />

如果 Client A 先取得了锁。Client B在等待 Client A 的工作完成。这个时候，Client A 被挂在了某些事上，比如一个外部的阻塞调用，或是 CPU 被别的进程吃满，或是不巧碰上了 Full GC，导致 Client A 花了超过平时几倍的时间。

然后，我们的锁服务因为怕死锁，就在一定时间后，把锁给释放掉了。此时，Client B 获得了锁并更新了资源。这个时候，Client A 服务缓过来了，然后也去更新了资源。于是乎，把 Client B 的更新给冲掉了。这就造成了数据出错。

要解决这个问题，需要引入 fence（栅栏）技术。一般来说，这就是乐观锁机制，需要一个版本号排它。

<img src="https://liuyang-picbed.oss-cn-shanghai.aliyuncs.com/img/ce3454e9a8bbfe4628899391c003a5c3.png" alt="ce3454e9a8bbfe4628899391c003a5c3" style="zoom:80%;" />

- 锁服务需要有一个单调递增的版本号。
- 写数据的时候，也需要带上自己的版本号。
- 数据库服务需要保存数据的版本号，然后对请求做检查。

如果使用 ZooKeeper 做锁服务的话，那么可以使用 zxid 或 znode 的版本号来做这个 fence 版本号。

**如果我们使用版本号，或是 fence token 这种方式，就不需要使用分布式锁服务了。**

##### 三、分布式锁设计的重点

可以使用数据库、Redis 或 ZooKeeper 来做分布式锁服务，这几种方式都可以用于实现分布式锁。

需要分清楚：是用来修改某个共享源的，还是用来不同进程间的同步或是互斥的。如果使用 CAS 这样的方式（无锁方式）来更新数据，那么我们是不需要使用分布式锁服务的，而后者可能是需要的。所以，在决定使用分布式锁服务前需要考虑的第一个问题——是否需要？

如果确定要分布式锁服务，需要考虑下面几个设计。

- 需要给一个锁被释放的方式，以避免请求者不把锁还回来，导致死锁的问题。Redis 使用超时时间，ZooKeeper 可以依靠自身的 sessionTimeout 来删除节点。
- 分布式锁服务应该是高可用的，而且是需要持久化的。对此，你可以看一下 Redis 的文档 RedLock 看看它是怎么做到高可用的。
- 要提供非阻塞方式的锁服务。
- 还要考虑锁的可重入性。