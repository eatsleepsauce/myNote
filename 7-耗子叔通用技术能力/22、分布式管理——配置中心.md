#### 配置中心 Configuration Management

##### 一、为什么需要配置中心

软件的配置信息，比如数据库的用户名和密码，还有一些我们不想写死在代码里的东西，像线程池大小、队列长度等运行参数，以及日志级别、算法策略等，还有一些是软件运行环境的参数，如 Java 的内存大小，应用启动的参数，包括操作系统的一些参数配置……

以前，我们把软件配置写在一个配置文件中，就像 Windows 下的 ini 文件，或是 Linux 下的 conf 文件。然而，在分布式系统下，这样的方式就变得非常不好管理，并容易出错。于是，为了便于管理，我们引入了一个集中式的配置管理系统，这就是配置中心的由来。

##### 二、区分软件的配置

有一种方式是把软件的配置分成 **静态配置** 和 **动态配置**。

**静态配置** 其实就是在软件启动时的一些配置，运行时基本不会进行修改，也可以理解为是环境或软件初始化时需要用到的配置。例如，操作系统的网络配置，软件运行时 Docker 进程的配置，这些配置在软件环境初始化时就确定了，未来基本不会修改了。

**动态配置** 其实就是软件运行时的一些配置，在运行时会被修改。比如，日志级别、降级开关、活动开关。

**配置中心主要针对动态配置的管理**，动态配置的管理一般来说有三个区分维度：

- **按运行环境区分**，一般来说，会有开发环境、测试环境、预发环境、生产环境。这些环境上的运行配置都不完全一样，但是理论来说，应该是大同小异的。
- **按依赖区分**，一种是 **依赖配置**，一种是 **不依赖的内部配置**。比如，外部依赖的 MySQL 或 Redis 的连接配置。还有一种完全是自己内部的配置。
- **按层次区分**，配置也可以分成 IaaS、PaaS、SaaS 三层。基础层的配置是操作系统的配置，中间平台层的配置是中间件的配置，如 Tomcat 的配置，上层软件层的配置是应用自己的配置。

##### 三、配置中心的模型

1. 软件配置基本上来讲，每个配置项就是 key/value的模型。
2. 把软件的配置分成三层。
   1. 操作系统层和平台层的配置项得由专门的运维人员或架构师来配置。其中的 value 应该是选项，而不是让用户可以自由输入的，最好是有相关的模板来初始化全套的配置参数。
   2. 应用层的配置项，需要有相应的命名规范，最好有像 C++ 那样的名字空间的管理，确保不同应用的配置项不会冲突。
3. 如果有 **外部服务依赖** 的配置，强烈建议不要放在配置中心里，而要放在 **服务发现系统** 中。
4. 对于不同运行环境中配置的差异来说，因为环境的不一样，会导致我们需要不同的配置项的值（例如：日志级别）。
5. 需要有一个整体的版本管理，每次变动都能将版本差异记录下来。如果可能，最好能和软件的版本号做关联。
6. 需要一个配置管理的工具，可能是命令行的，也可以是 Web 的。
7. 配置中心还需要提 API 来让应用获取配置。这个 API 上至少需要有如下参数：服务名，配置的版本号，配置的环境。

下图是配置管理工具的一个模型：

<img src="https://liuyang-picbed.oss-cn-shanghai.aliyuncs.com/img/5aeb4055738bd15188a007ccbbbc38b7.png" alt="5aeb4055738bd15188a007ccbbbc38b7" style="zoom:50%;" />

##### 四、配置中心的架构（落地）

<img src="https://liuyang-picbed.oss-cn-shanghai.aliyuncs.com/img/745c444c53457239de884a943adff1b5.png" alt="745c444c53457239de884a943adff1b5" style="zoom:67%;" />

在这个图中可以看到，我们把配置录入后，配置中心发出变更通知，配置变更控制器会来读取最新的配置，然后应用配置。

- **为什么需要一个变更通知的组件**， 分布式环境下，服务器太多，推送不太现实，而采用一个 Pub/Sub 的通知服务可以让数据交换经济一些。
- **为什么要订阅方反向拉数据**，直接推数据当然可以，但让程序反过来用 API 读配置的好处是，一方面，API 可以校验请求者的权限，另一方面，有时候还是需要调用配置中心的基本 API，比如下载最新的证书之类的。还有就是，服务启动时需要从服务中心拉一份配置下来。（依赖倒置）
- **配置变更控制器部署在哪里**，建议把这个配置变更的控制放在每一台主机上。
- **平台层的配置变更**，有的参数是在服务启动的命令行上，一般来说，命令行上的参数需要通过 Shell 环境变量做成配置项，然后通过更改系统环境变量，并重启服务达到配置变更。
- 操作系统的配置变更和平台层的配置变更最好模块化掉，就像云服务中的不同尺寸的主机型号一样。 这样有利于维护和减少配置的复杂性。
- 应用服务配置更新的标准化。
  - 可以通过一个开发框架或 SDK 的方式来解决，也就是应用代码通过SDK 来要配置，并通过 observer 模式订阅配置修改的事件，或是直接提供配置变更的 Admin 的 API。这种方式的好处在于在开发期标准化，并可以规范开发；不好的是，耦合语言。
  - 通过一个标准应用运维脚本，让应用方自己来提供应用变更时的脚本动作。这种方式虽然通过运维的方式标准化掉配置变更的接口，就可以通过一个配置控制器来统一操作各个应用变更，但是在这个脚本中各个应用方依然使用着各种不同的方式来变更配置。这种方式的好处是不耦合语言，灵活，但对于标准化的建设可能不利，而且使用或者调用脚本是 Bug 很多的东西，容易出问题。
  - 或是结合上述两种方案，不使用开发阶段的 SDK 方式嵌入到应用服务中，而是为每个应用服务单独做一个 Agent。这个 Agent 对外以 Admin API 的方式服务，后面则适配应用的配置变更手段，如更新配置文件，或者调用应用的 API 等。

##### 五、配置中心的设计重点

- 配置更新的时候是一个事务处理，需要考虑事务的问题，如果变更不能继续，需要回滚到上个版本的配置。配置版本最好和软件版本对应上。
- 配置更新控制器，需要应用服务的配合，比如，配置的 reload，服务的优雅重启，服务的 Admin API，或是通过环境变量……这些最好是由一个统一的开发框架搞定。
- 配置更新控制器还担任服务启动的责任，由配置更新控制器来启动服务。。这样，配置控制器会从配置中心拉取所有的配置，更新操作系统，设置好启动时用的环境变量，并更新好服务需要的配置文件 ，然后启动服务。