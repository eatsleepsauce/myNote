#### 补偿事务Compensating Transaction

##### 一、背景

分布式系统有一个比较明显的问题就是，一个业务流程需要组合一组服务。这样的事情在微服务下就更为明显了，因为这需要业务上一致性的保证。也就是说，如果一个步骤失败了，那么要么回滚到以前的服务调用，要么不断重试保证所有的步骤都成功。

如果需要强一致性，那在业务层上就需要使用“两阶段提交”这样的方式。但是好在我们的很多情况下并不需要这么强的一致性，而且强一致性的最佳保证基本都是在底层完成的，或是像之前说的那样 Stateful 的 Sticky Session 那样在一台机器上完成。在我们 **接触到的大多数业务中，其实只需要最终一致性就够了**。

##### 二、ACID 和 BASE

传统关系型数据库系统的事务都有 ACID 属性，即原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation，又称独立性）、持久性（Durability）。

- **原子性**：整个事务中的所有操作，要么全部完成，要么全部失败，不可能停滞在中间某个环节。事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。
- **一致性**：在事务开始之前和事务结束以后，数据库的完整性约束没有被破坏。
- **隔离性**：两个事务的执行是互不干扰的，一个事务不可能看到其他事务运行时中间某一时刻的数据。两个事务不会发生交互。
- **持久性**：在事务完成以后，该事务对数据库所做的更改便持久地保存在数据库之中，并不会被回滚。

对于分布式系统来说，尤其是微服务来说，这样的方式是很难满足高性能要求的。 CAP 理论——在分布式的服务架构中，一致性（Consistency）、可用性（Availability）、分区容忍性（Partition Tolerance），在现实中不能都满足，最多只能满足其中两个。所以，为了提高性能，出现了 ACID 的一个变种 BASE。

- **Basic Availability**：基本可用。这意味着，系统可以出现暂时不可用的状态，而后面会快速恢复。
- **Soft-state**：软状态。它是“有状态”和“无状态”的服务的一种中间状态。也就是说，为了提高性能，可以让服务暂时保存一些状态或数据，这些状态和数据不是强一致性的。
- **Eventual Consistency**：最终一致性。系统在一个短暂的时间段内是不一致的，但最终整个系统看到的数据是一致的。

**在分布式系统的世界里，故障是不可避免的，我们能做的就是把故障处理当成功能写入代码中，这就是 Design for Failure。**

##### 三、业务补偿

一般来说，业务的事务补偿都是需要一个 **工作流引擎** 的。这个工作流引擎 **把各式各样的服务给串联在一起，并在工作流上做相应的业务补偿**，整个过程设计成为最终一致性的。

业务补偿机制需要做到以下几点：

1. **业务起始状态定义**，要能清楚地描述出要达到什么样的状态，以及如果其中的条件不满足，那么，我们要回退到哪一个状态。
2. **状态拟合**，当整条业务跑起来的时候，我们可以串行或并行地做这些事。总之，我们的系统需要努力地通过一系列的操作达到一个我们想要的状态。如果达不到，就需要通过补偿机制回滚到之前的状态。
3. 对于已经完成的事务进行整体修改，可以考虑成一个修改事务。

业务补偿的设计重点：

- 要把一个业务流程执行完成，需要这个流程中所涉及的服务方支持幂等性。并且在上游有重试机制。
- 需要小心维护和监控整个过程的状态，所以，千万不要把这些状态放到不同的组件中，最好是一个业务流程的控制方来做这个事，也就是一个工作流引擎。所以，这个工作流引擎是需要高可用和稳定的。
- 补偿的业务逻辑和流程不一定非得是严格反向操作。有时候可以并行，有时候，可能会更简单。总之，设计业务正向流程的时候，也需要设计业务的反向补偿流程。
- 业务补偿的业务逻辑是强业务相关的，很难做成通用的
- 下层的业务方最好提供短期的资源预留机制（就像电商中的把货品的库存预先占住等待用户在 15 分钟内支付。如果没有收到用户的支付，则释放库存。然后回滚到之前的下单操作，等待用户重新下单。）。



