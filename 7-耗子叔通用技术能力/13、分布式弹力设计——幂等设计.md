#### 幂等设计Idempotency

##### 一、幂等性介绍

所谓幂等性设计，就是说，一次和多次请求某一个资源应该具有同样的副作用。

在系统解耦隔离后，服务间的调用可能会有三个状态，一个是成功（Success），一个是失败（Failed），一个是超时（Timeout）。前两者都是明确的状态，而超时则是完全不知道是什么状态。所以需要幂等这样的操作。

因为系统超时，而调用户方重试一下，会给我们的系统带来不一致的副作用，在这种情况下，一般有两种处理方式：

- 一种是需要下游系统提供相应的查询接口。
- 另一种是通过幂等性的方式。把这个查询操作交给下游系统，上游系统只管重试，下游系统保证一次和多次的请求结果是一样的。

##### 二、全局ID

要做到幂等性的交易接口，需要有一个唯一的标识，来标志交易是同一笔交易。而这个交易 ID 由谁来分配是一件比较头疼的事。因为这个标识要能做到全局唯一。

为了解决分配冲突的问题，我们需要使用一个不会冲突的算法，比如使用 UUID 这样冲突非常小的算法（不使用中心系统来分配ID原因，是避免额外的性能开销）。但 UUID 的问题是，它的字符串占用的空间比较大，索引的效率非常低，生成的 ID 太过于随机，完全不是人读的，而且没有递增，如果要按前后顺序排序的话，基本不可能。在全局唯一 ID 的算法中，这里介绍一个 Twitter 的开源项目 Snowflake。它是一个分布式 ID 的生成算法。其核心思想是，产生一个 long 型的 ID，其中：

- 41bits 作为毫秒数。大概可以用 69.7 年。
- 10bits 作为机器编号（5bits 是数据中心，5bits 的机器 ID），支持 1024 个实例。
- 12bits 作为毫秒内的序列号。一毫秒可以生成 4096 个序号。

![2bda719052cb3b584c0db93e89d32528](https://liuyang-picbed.oss-cn-shanghai.aliyuncs.com/img/2bda719052cb3b584c0db93e89d32528.png)

其他的像Redis或MongoDB的全局ID生成都和这个算法大同小异。

##### 三、幂等处理流程

对于幂等性的处理流程来说，说白了就是要过滤一下已经收到的交易。要做到这个事，我们需要一个存储来记录收到的交易。

于是，当收到交易请求的时候，我们就会到这个存储中去查询。如果查找到了，那么就不再做查询了，并把上次做的结果返回。如果没有查到，那么我们就记录下来。

![4c078da5bf5833cebc08a57bfb332b1b](https://liuyang-picbed.oss-cn-shanghai.aliyuncs.com/img/4c078da5bf5833cebc08a57bfb332b1b.png)

上面这个流程有个问题。因为绝大多数请求应该都不会是重新发过来的，所以让 100% 的请求都到这个存储里去查一下，这会导致处理流程变得很慢。

所以，最好是当这个存储出现冲突的时候会报错。收到交易请求后，直接去存储里记录这个 ID（相对于数据的 Insert 操作），如果出现 ID 冲突了的异常，那么我们就知道这个之前已经有人发过来了，所以就不用再做了。比如，数据库中你可以使用 insert into … values … on DUPLICATE KEY UPDATE … 这样的操作。

对于更新的场景来说，如果只是状态更新，可以使用如下的方式。如果出错，要么是非法操作，要么是已被更新，要么是状态不对，总之多次调用是不会有副作用的。update table set status = “paid” where id = xxx and status = “unpaid”;

幂等性服务是分布式的，所以，需要这个 **存储也是共享的**。这样每个服务就变成没有状态的了。但是，这个存储就成了一个非常关键的依赖，其扩展性和可用性也成了非常关键的指标。可以使用关系型数据库，或是 key-value 的 NoSQL（如 MongoDB）来构建这个存储系统。



Http Post方式很可能出现多次提交的问题，针对这样的幂等性设计如下：

- 首先，在表单中需要隐藏一个 token，这个 token 可以是前端生成的一个唯一的 ID。用于防止用户多次点击了表单提交按钮，而导致后端收到了多次请求，却不能分辨是否是重复的提交。这个 token 是表单的唯一标识。（这种情况其实是通过前端生成 ID 把 POST 变成了 PUT。）
- 然后，当用户点击提交后，后端会把用户提交的数据和这个 token 保存在数据库中。如果有重复提交，那么数据库中的 token 会做排它限制，从而做到幂等性。
- 更为稳妥的做法是，后端成功后向前端返回 302 跳转，把用户的前端页跳转到 GET 请求，把刚刚 POST 的数据给展示出来。如果是 Web 上的最好还把之前的表单设置成过期，这样用户不能通过浏览器后退按钮来重新提交。这个模式又叫做 PRG 模式（Post/Redirect/Get）。