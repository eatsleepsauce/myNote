#### 网关模式 Gateway

##### 一、网关架构介绍

![2c82836fe26b71ce6ad228bf285795f9](https://liuyang-picbed.oss-cn-shanghai.aliyuncs.com/img/2c82836fe26b71ce6ad228bf285795f9.png)

Gateway 是一个服务器，也可以说是进入系统的唯一节点。这跟面向对象设计模式中的 Facade 模式很像。Gateway 封装内部系统的架构，并且提供 API 给各个客户端。它还可能有其他功能，如授权、监控、负载均衡、缓存、熔断、降级、限流、请求分片和管理、静态响应处理，等等。

##### 二、网关模式设计

一个网关需要有以下的功能：

- **请求路由**，调用端不需要知道自己需要用到的其它服务的地址，全部统一地交给 Gateway 来处理。
- **服务注册**，后端的服务实例可以把其提供服务的地址注册、取消注册。一般来说，注册也就是注册一些 API 接口。比如，HTTP 的 Restful 请求，可以注册相应 API 的 URI、方法、HTTP 头。 这样，Gateway 就可以根据接收到的请求中的信息来决定路由到哪一个后端的服务上。
- **负载均衡**，需要在各个对等的服务实例上做负载均衡策略。简单点就是直接 Round-Robin 轮询，复杂点的可以设置上权重进行分发，再复杂一点还可以做到 session 粘连。
- **弹力设计**，可以把弹力设计中的那些异步、重试、幂等、流控、熔断、监视等都可以实现进去。这样，应用服务只关心自己的业务逻辑（或是说数据面上的事）而不是控制逻辑（控制面）。

- **安全方面**，SSL 加密及证书管理、Session 验证、授权、数据校验，以及对请求源进行恶意攻击的防范。错误处理越靠前的位置就是越好，所以，网关可以做到一个全站的接入组件来对后端的服务进行保护。

网关还可以做一些其它有趣的事情，比如：

- **灰度发布**，可以做到对相同服务不同版本的实例进行导流，还可以收集相关的数据。
- API**聚合**，网关可以将多个单独请求聚合成一个请求。在微服务体系的架构中，因为服务变小了，所以一个明显的问题是，客户端可能需要多次请求才能得到所有的数据。
- **API编排**，同样在微服务的架构下，要走完一个完整的业务流程，我们需要调用一系列 API，就像一种工作流一样，这个事完全可以通过网页来编排这个业务流程。我们可能通过一个 DSL 来定义和编排不同的 API，也可以通过像 AWS Lambda 服务那样的方式来串联不同的 API。

##### 三、Gateway、Sidecar和Service Mesh

网关、边车和 Service Mesh 是非常像的三种设计模式，很容易混淆。这三种设计模式的特点、场景和区别如下：

Sidecar 的方式主要是用来改造已有服务。

Sidecar 在架构中越来越多时，需要我们对 Sidecar 进行统一的管理。于是，我们为 Sidecar 增加了一个全局的中心控制器，就出现了我们的 Service Mesh。在中心控制器出现以后，我们发现，可以把非业务功能的东西全部实现在 Sidecar 和 Controller 中，于是就成了一个网格。业务方只需要把服务往这个网格中一放就好了，与其它服务的通讯、服务的弹力等都不用管了，像一个服务的 PaaS 平台。

Service Mesh 的架构和部署太过于复杂，会让我们运维层面上的复杂度变大。

Gateway 只负责进入的请求，不像 Sidecar 还需要负责对外的请求。因为Gateway 可以把一组服务给聚合起来，所以服务对外的请求可以交给对方服务的 Gateway。

##### 四、网关的设计重点

###### 1、高性能

在技术设计上，网关不应该也不能成为性能的瓶颈。对于高性能，最好使用高性能的编程语言来实现，如 C、C++、Go 和 Java。

网关对后端的请求，以及对前端的请求的服务一定要使用异步非阻塞的 I/O 来确保后端延迟不会导致应用程序中出现性能问题。C 和 C++ 可以参看 Linux 下的 epoll 和 Windows 的 I/O Completion Port 的异步 IO 模型，Java 下如 Netty、Vert.x、Spring Reactor 的 NIO 框架。Go 语言的 goroutine 加 channel 玩法。

###### 2、高可用

因为所有的流量或调用经过网关，所以网关必须成为一个高可用的技术组件，它的稳定直接关系到了所有服务的稳定。

- **集群化**，网关要成为一个集群，其最好可以自己组成一个集群，并可以自己同步集群数据，而不需要依赖于一个第三方系统来同步数据。
- **服务化**，网关还需要做到在不间断的情况下修改配置，一种是像 Nginx reload 配置那样，可以做到不停服务，另一种是最好做到服务化。也就是说，得要有自己的 Admin API 来在运行时修改自己的配置。
- **持续化**，比如重启，就是像 Nginx 那样优雅地重启。有一个主管请求分发的主进程。当我们需要重启时，新的请求被分配到新的进程中，而老的进程处理完正在处理的请求后就退出。

###### 3、高扩展

因为网关需要承接所有的业务流量和请求，所以一定会有或多或少的业务逻辑。而业务逻辑是多变和不确定的。

比如，需要在网关上加入一些和业务相关的东西。因此，一个好的 Gateway 还需要是可以扩展的，并能进行二次开发的。当然，像 Nginx 那样通过 Module 进行二次开发的固然可以。但应该做成像 AWS Lambda 那样的方式，也就是所谓的 Serverless 或 FaaS（Function as a Service）那样的方式。

###### 4、运维方面

- **业务松耦合，协议紧耦合**。

  网关不应与后面的服务之间形成服务耦合，也不应该有业务逻辑。网关应该是在网络应用层上的组件，不应该处理通讯协议体，只应该解析和处理通讯协议头。另外，除了服务发现外，网关不应该有第三方服务的依赖。

- **应用监视，提供分析数据**。

  网关上需要考虑应用性能的监控，除了有相应后端服务的高可用的统计之外，还需要使用 Tracing ID 实施分布式链路跟踪，并统计好一定时间内每个 API 的吞吐量、响应时间和返回码，以便启动弹力设计中的相应策略。

- **用弹力设计保护后端服务**。

  网关上一定要实现熔断、限流、重试和超时等弹力设计。

- **DevOps**。

  因为网关这个组件太关键了，所以需要 DevOps 这样的东西，将其发生故障的概率降到最低。

###### 5、架构方面

- 不要在网关中的代码里内置聚合后端服务的功能，而应考虑将聚合服务放在网关核心代码之外。可以使用 Plugin 的方式，也可以放在网关后面形成一个 Serverless 服务。
- 网关应该靠近后端服务，并和后端服务使用同一个内网，这样可以保证网关和后端服务调用的低延迟，并可以减少很多网络上的问题。
- **网关也需要做容量扩展**，所以需要成为一个集群来分担前端带来的流量。这一点，**要么通过 DNS 轮询的方式实现，要么通过 CDN 来做流量调度，或者通过更为底层的性能更高的负载均衡设备**。
- 对于服务发现，可以做一个时间不长的缓存，这样不需要每次请求都去查一下相关的服务所在的地方。当然，如果你的系统不复杂，可以考虑把服务发现的功能直接集成进网关中。
- 为网关考虑 bulkhead 设计方式。用不同的网关服务不同的后端服务，或是用不同的网关服务前端不同的客户。

###### 6、安全方面

- **加密数据**，可以把 SSL 相关的证书放到网关上，由网关做统一的 SSL 传输管理。
- **校验用户的请求**，一些基本的用户验证可以放在网关上来做，比如用户是否已登录，用户请求中的 token 是否合法等。

- **检测异常访问**，网关需要检测一些异常访问，比如，在一段比较短的时间内请求次数超过一定数值；还比如，同一客户端的 4xx 请求出错率太高……对于这样的一些请求访问，网关一方面要把这样的请求屏蔽掉，另一方面需要发出警告，有可能会是一些比较重大的安全问题，如被黑客攻击。