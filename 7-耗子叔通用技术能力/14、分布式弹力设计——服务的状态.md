#### 服务的状态State

所谓“状态”，就是为了保留程序的一些数据或是上下文。比如用户登录时的 Session，我们需要这个 Session 来判断这个请求的合法性，还有一个业务流程中需要让多个服务组合起来形成一个业务逻辑的运行上下文 Context。这些都是所谓的状态。

##### 一、无状态的服务Stateless

###### 1、无状态的好处

**一直以来，无状态的服务都被当作分布式服务设计的最佳实践和铁律**。因为无状态的服务对于扩展性和运维实在是太方便了。没有状态的服务，可以随意地增加和减少节点，同样可以随意地搬迁。而且，无状态的服务可以大幅度降低代码的复杂度以及 Bug 数，因为没有状态，所以也没有明显的“副作用”。

但是，现实世界是一定会有状态的。这些状态可能表现在如下的几个方面：

- **程序调用的结果**
- **服务组合下的上下文**
- **服务的配置**

###### 2、无状态的实现

为了做出无状态的服务，我们通常需要把状态保存到其他的地方。比如，不太重要的数据可以放到 Redis 中，重要的数据可以放到 MySQL 中，或是像 ZooKeeper/Etcd 这样的高可用的强一致性的存储中，或是分布式文件系统中。

带来的问题，这会导致这些服务需要耦合第三方有状态的存储服务。一方面是有依赖，另一方面也增加了网络开销，导致服务的响应时间也会变慢。

##### 二、有状态的服务Stateful

###### 1、有状态的好处

无状态服务在程序 Bug 上和水平扩展上有非常优秀的表现，但是其需要把状态存放在一个第三方存储上，增加了网络开销，而在服务内的缓存需要在所有的服务实例上都有（因为每次请求不会都落在同一个服务实例上），这是比较浪费资源的。

有状态的服务有这些好处：

- **数据本地化（Data Locality）**，一方面状态和数据是本机保存，这方面不但有更低的延时，而且对于数据密集型的应用来说，这会更快。
- **更高的可用性和更强的一致性，也就是 CAP 原理中的 A 和 C。**

###### 2、有状态的实现

对于有状态的服务，**需要对于客户端传来的请求，都必需保证其落在同一个实例上**，这叫 **Sticky Session（黏性会话）** 或是 Sticky Connection。

无状态的服务需要我们把数据同步到不同的节点上，而有状态的服务通过 Sticky Session 做数据分片（当然，同步有同步的问题，分片也有分片的问题，这两者没有谁比谁好，都有 trade-off）。



**Sticky Session 是怎么实现的呢？**



##### 三、服务状态的容错设计

需要使用底层的分布式文件系统，对于有状态的数据不但在运行时进行多节点间的复制，同时为了避免挂掉，还需要把数据持久化在硬盘上，这个硬盘可以是挂载到本地硬盘的一个外部分布式的文件卷。

这样当节点挂掉以后，以另外一个宿主机上启动一个新的服务实例时，这个服务可以从远程把之前的文件系统挂载过来。然后，在启动的过程中就装载好了大多数的数据，从而可以从网络其它节点上同步少量的数据，因而可以快速地恢复和提供服务。

对于有状态的服务来说非常关键。所以，使用一个分布式文件系统是调度有状态服务的关键。