#### 异步处理 Asynchronous

异步通讯的设计模式有助于提高系统的稳定性和容错能力。其实，异步通讯在分布式系统中还可以 **增加整个系统的吞吐量**，从而可以面对更高的并发，并可以从容地利用好现有的系统资源。

##### 一、异步处理的设计

1. 需要一个前台系统，把用户发来的请求一一记录下来，有点像请求日志。操作在数据库或是存储上只会有追加的操作(顺序写)，性能会很高。我们收到请求后，给客户端返回“收到请求，正在处理中”。
2. 然后，有个任务处理系统来真正地处理收到的这些请求。为了解耦，需要一个任务派发器，这里就会出来两个事，一个是推模型 Push，一个是拉模型 Pull。
   1. Push 推模型，就是把任务派发给相应的人去处理，有点像是一个工头的调度者的角色。
   2. Pull 拉模型，则是由处理的人来拉取任务处理。
   3. Push 模型可以做调度，但是它需要知道下游工作结点的情况。而 Pull 的好处则是可以让上游结点不用关心下游结点的状态，只要自己忙得过来，就会来拿任务处理，这样可以减少一定的复杂度，但是少了整体任务调度。

一般来说，我们构建的都是推拉结合的系统，Push 端会做一定的任务调度，比如它可以像物流那样把相同商品的订单都合并起来，打成一个包，交给下游系统让其一次处理掉；也可以把同一个用户的订单中的不同商品给拆成多个订单。然后 Pull 端来订阅 Push 端发出来的异步消息，处理相应的任务。

##### 二、事件溯源 Event Sourcing设计

所谓 Event Sourcing，其主要想解决的问题是，我们可以看到数据库中的一个数据的值（状态），但我们完全不知道这个值是怎么得出来的。就像银行的存折一样，我们可以在银行的存折看到我们收支的所有记录，也能看得到每一笔记录后的余额。

如果我们有了所有的收支流水账的记录，我们完全不需要保存余额，因为我们只需要回放一下所有的收支事件，就可以得到最终的数据状态。这样一来，我们的系统就会变得非常简单，只需要追加不可修改的数据操作事件，而不是保存最终状态。除了可以提高性能和响应时间之外，还可以提供事务数据一致性，并保留了可以启用补偿操作的完整记录和历史记录。

还有一个好处，就是如果我们的代码里有了 bug，在记录状态的系统里，我们修改 bug 后还需要做数据修正。然而，在 Event Sourcing 的系统里，我们只需要把所有事件重新播放一遍就好了，因为整个系统没有状态了。

事件溯源不需要直接更新数据存储中的对象，因而有助于防止并发更新造成冲突。

最重要的是，异步处理 + 事件溯源的方式，可以很好地让我们的整个系统进行任务的统筹安排、批量处理，可以让整体处理过程达到性能和资源的最大化利用。

##### 三、异步处理的分布式事务

对于分布式事务，在强一致性下，在业务层上只能做两阶段提交，而在数据层面上需要使用 Raft/Paxos 的算法。但是，在现实生活中，需要用到强一致性的场景实在不多，不是所有的场景都必须要强一致性的事务的。

完全可以使用异步的方式来达到一致性，当然，是最终一致性。要达到最终一致性，我们需要有个交易凭证。也就是说，如果一个事务需要做 A 和 B 两件事。

在达成这个事务的过程中，有几点需要注意。

- 凭证需要非常好地保存起来，不然会导致事务做不下去。
- 凭证处理的幂等性问题，不然在重试时就会出现多次交易的情况。
- 如果事务完成不了，需要做补偿事务处理。



在运维时，我们要监控任务队列里的任务积压情况。如果有任务积压了，要能做到快速地扩容。如果不能扩容，而且任务积压太多，可能会导致整个系统挂掉，那么就要开始对前端流量进行限流。

异步处理系统的本质是把被动的任务处理变成主动的任务处理，其本质是在对任务进行调度和统筹管理。