#### 分布式系统的服务调度

##### 一、服务关键程度和服务的依赖关系

###### 1、服务关键程度

服务关键程度，主要是梳理和定义服务的重要程度。这不是使用技术可以完成的，它需要细致地管理对业务的理解，才能定义出架构中各个服务的重要程度。

###### 2、服务依赖关系

梳理出服务间的依赖关系，这点也非常重要。“没有依赖，就没有伤害”。

- **依赖问题**

依赖关系就像“铁锁连环”一样，一个服务的问题很容易出现一条链上的问题。因此，传统的 SOA 希望通过 ESB 来解决服务间的依赖关系，这也是为什么微服务中希望服务间是没有依赖的，而让上层或是前端业务来整合这些个后台服务。

- **解决方案**

**微服务是服务依赖最优解的上限，而服务依赖的下限是千万不要有依赖环。**解决服务依赖环的方案一般是，依赖倒置的设计模式。在分布式架构上，可以使用一个第三方的服务来解决这个事。比如，通过订阅或发布消息到一个消息中间件，或是把其中的依赖关系抽到一个第三方的服务中，然后由这个第三方的服务来调用这些原本循环依赖的服务。

- **技术手段发现依赖关系**

服务的依赖关系是可以通过技术的手段来发现的，这其中，Zipkin是一个很不错的服务调用跟踪系统，它是通过 Google Dapper这篇论文来实现的。这个工具可以帮你梳理服务的依赖关系，以及了解各个服务的性能。

##### 二、服务状态和生命周期的管理（服务发现）

有了依赖关系的地图后，还需要有一个 **服务发现的中间件**，这个中间件是非常非常关键的。因为这个“架构城市”是非常动态的，有的服务会新加进来，有的会离开，有的会增加更多的实例，有的会减少，有的服务在维护过程中（发布、伸缩等），所以 **需要有一个服务注册中心**。

服务注册中心可以让我们知道这几个事：

- 整个架构中有多少种服务

- 这些服务的版本是什么样的
- 每个服务的实例数有多少个，它们的状态是什么样的
- 每个服务的状态是什么样的，是在部署中，运行中，故障中，升级中，还是在回滚中，伸缩中，或者是在下线中……

服务的生命周期通常会有以下几个状态：

- Provision，代表在供应一个新的服务
- Ready，表示启动成功了
- Run，表示通过了服务健康检查
- Update，表示在升级中
- Rollback，表示在回滚中
- Scale，表示正在伸缩中（Scale-in 垂直伸缩 和 Scale-out水平伸缩）

- Destroy，表示在销毁中
- Failed，表示失败状态

##### 三、整个架构的版本管理

在分布式架构中，需要一个 **架构的版本**，用来控制其中各个服务的版本兼容。比如，A 服务的 1.2 版本只能和 B 服务的 2.2 版本一起工作，A 服务的上个版本 1.1 只能和 B 服务的 2.0 一起工作。这就是 **版本兼容性**。

当然，一般来说，在设计过程中，我们希望没有版本的依赖性问题。但如果架构中有这样的问题，那么我们就需要一个上层架构的版本管理。这样，如果我们要回滚一个服务的版本，就可以把与之有版本依赖的服务也一起回滚掉。

要做到这个事，需要一个架构的 manifest，一个服务清单，这个服务清单定义了所有服务的版本运行环境，其中包括但不限于：

- 服务的软件版本
- 服务的运行环境——环境变量、CPU、内存、可以运行的节点、文件系统等
- 服务运行的最大最小实例数

每一次对这个清单的变更都需要被记录下来，算是一个架构的版本管理。

##### 四、资源/服务调度

服务和资源的调度有点像操作系统。操作系统一方面把用户进程在硬件资源上进行调度，另一方面提供进程间的通信方式，可以让不同的进程在一起协同工作。服务和资源调度的过程，与操作系统调度进程的方式很相似，主要有以下一些关键技术。

- 服务状态的维持和拟合。
- 服务的弹性伸缩和故障迁移。
- 作业和应用调度。
- 作业工作流编排。
- 服务编排。

###### 1、服务状态的维持和拟合

所谓服务状态不是服务中的数据状态，而是服务的运行状态。换句话说就是服务的 Status，而不是 State。也就是上述服务运行时生命周期中的状态——Provision，Ready，Run，Scale，Rollback，Update，Destroy，Failed……

服务运行时的状态是非常关键的。服务运行过程中，状态也是会有变化的，这样的变化有两种。

- 一种是不预期的变化。比如，服务运行因为故障导致一些服务挂掉，或是别的什么原因出现了服务不健康的状态。而一个好的集群管理控制器应该能够强行维护服务的状态。在健康的实例数变少时，控制器会把不健康的服务给摘除，而又启动几个新的，强行维护健康的服务实例数。

- 另外一种是预期的变化。比如，我们需要发布新版本，需要伸缩，需要回滚。这时，集群管理控制器就应该把集群从现有状态迁移到另一个新的状态。这个过程并不是一蹴而就的，集群控制器需要一步一步地向集群发送若干控制命令。这个过程叫 **“拟合” ——从一个状态拟合到另一个状态，而且要穷尽所有的可能，玩命地不断地拟合，直到达到目的**。

**“拟合”** 这个操作的过程一定是比较“慢”的。一方面，需要对其它操作排它；另一方面，在整个过程中，我们的控制系统需要努力地逼近最终状态，直到完全达到。此外，正在运行的服务可能也会出现问题，离开了我们想要的状态，而控制系统检测到后，会强行地维持服务的状态。

Kubernetes 就是这样的一个调度控制系统。

###### 2、服务的弹性伸缩和故障迁移

（1）**弹性伸缩**

一个服务伸缩所需要的操作步骤。还是比较复杂的，其中涉及到了：

- 底层资源的伸缩
- 服务的自动化部署
- 服务的健康检查
- 服务的注册发现
- 服务的流量调度

（2）**故障迁移**

故障迁移，也就是服务的某个实例出现问题时，我们需要自动地恢复它。对于服务来说，有两种模式，一种是宠物模式，一种是奶牛模式。

- 所谓宠物模式，就是一定要救活，主要是对于 stateful 的服务。
- 而奶牛模式，就是不救活了，重新生成一个实例。

对于这两种模式，在运行中也是比较复杂的，其中涉及到了：

- 服务的健康监控（这可能需要一个 APM 的监控）
- 如果是宠物模式，需要：服务的重新启动和服务的监控报警（如果重试恢复不成功，需要人工介入）。
- 如果是奶牛模式，需要：服务的资源申请，服务的自动化部署，服务发现的注册，以及服务的流量调度。

**把传统的服务迁移到 Docker 和 Kubernetes 上来，再加上更上层的对服务生命周期的控制系统的调度，我们就可以做到一个完全自动化的运维架构了。**

###### 3、服务工作流和编排

和操作系统做的类比一样，一个好的操作系统需要能够通过一定的机制把一堆独立工作的进程给协同起来。在分布式的服务调度中，这个工作叫做 **Orchestration（“编排”）**。

编排工作在传统的 SOA中 是通过 ESB（Enterprise Service Bus）——企业服务总线来完成的。ESB 的主要功能是服务通信路由、协议转换、服务编制和业务规则应用等。

ESB 的服务编制叫 Choreography（编舞），与 Orchestration 是不一样的：

- Orchestration 的意思是，一个服务像大脑一样来告诉大家应该怎么交互，就跟乐队的指挥一样。（查看Service-oriented Design：A Multi-viewpoint Approach，了解更多信息）。
- Choreography 的意思是，在各自完成专属自己的工作的基础上，怎样互相协作，就跟芭蕾舞团的舞者一样。

在微服务中，使用更为轻量的中间件来取代 ESB 的服务编排功能。简单来说，这需要一个 API Gateway 或一个简单的消息队列来做相应的编排工作。在 Spring Cloud 中，所有的请求都统一通过 API Gateway（Zuul）来访问内部的服务。这个和 Kubernetes 中的 Ingress 相似。