#### 二进制——计算机的源头

##### 一、什么是二进制

阿拉伯数字由从 0 到 9 这样 10 个计数符号组成，并采取进位制法，高位在左，低位在右，从左往右书写。

数字：2871

<img src="https://liuyang-picbed.oss-cn-shanghai.aliyuncs.com/img/d99f094c432638924f8665a178162c3d.jpg" alt="img" style="zoom: 50%;" />

其中 ^ 表示幂或次方运算。十进制的数位（千位、百位、十位等）全部都是 10^n 的形式。需要特别注意的是，任何非 0 数字的 0 次方均为 1。在这个新的表示式里，10 被称为十进制计数法的 **基数**，也是十进制中“十”的由来。

**十进制计数是使用 10 作为基数，那么二进制就是使用 2 作为基数**，类比过来，二进制的数位就是 2^n 的形式。

<img src="https://liuyang-picbed.oss-cn-shanghai.aliyuncs.com/img/c6ae1772d7bf369aa9939fc00ca7b5c0.jpg" alt="img" style="zoom:50%;" />

##### 二、计算机为什么使用二进制

组成计算机系统的逻辑电路通常只有两个状态，即开关的接通与断开。

断开的状态我们用“0”来表示，接通的状态用“1”来表示。由于每位数据只有断开与接通两种状态，所以即便系统受到一定程度的干扰时，它仍然能够可靠地分辨出数字是“0”还是“1”。**二进制的数据表达具有抗干扰能力强、可靠性高的优点**。

**二进制也非常适合逻辑运算**。逻辑运算中的“真”和“假”，正好与二进制的“0”和“1”两个数字相对应。逻辑运算中的加法（“或”运算）、乘法（“与”运算）以及否定（“非”运算）都可以通过“0”和“1”的加法、乘法和减法来实现。

##### 三、二进制的位操作

###### 1、向左移位

二进制 110101 向左移一位，就是在末尾添加一位 0，因此 110101 就变成了 1101010。

请注意，这是数字没有溢出的情况。所谓数字溢出，就是二进制数的位数超过了系统所指定的位数。目前主流的系统都支持至少 32 位的整型数字，而 1101010 远未超过 32 位，所以不会溢出。如果进行左移操作的二进制已经超出了 32 位，左移后数字就会 **溢出，需要将溢出的位数去除 **。

**二进制左移一位，其实就是将数字翻倍。**

<img src="https://liuyang-picbed.oss-cn-shanghai.aliyuncs.com/img/cdbeb658035f275aa941a0d3f6eac876.jpg" alt="img" style="zoom: 33%;" />

###### 2、向右移位

**二进制右移一位，就是将数字除以 2 并求整数商的操作。**

<img src="https://liuyang-picbed.oss-cn-shanghai.aliyuncs.com/img/8df282639b609d5269582c789796c334.jpg" alt="img" style="zoom: 33%;" />

Java 里定义了两种右移，逻辑右移 >>> 和 算术右移 >>。

- 逻辑右移 1 位，左边补 0 即可。

- 算术右移时保持符号位不变，除符号位之外的右移一位并补符号位 1。补的 1 仍然在符号位之后。

在 C 或 C++ 语言中，逻辑右移和算数右移共享同一个运算符 >>。编译器决定使用逻辑右移还是算数右移，根据运算数的类型。如果运算数类型是 unsigned，则采用逻辑右移；而是 signed，则采用算数右移。如果对 unsigned 类型的数据使用算数右移，或者针对 signed 类型的数据使用逻辑右移，那么首先需要进行类型的转换。

###### 3、位的“或”

“或”的意思是，参与操作的位中只要有一个位是 1，那么最终结果就是 1，也就是“真”。如果我们将二进制 110101 和 100011 的每一位对齐，进行按位的“或”操作，就会得到 110111。

###### 4、位的“与”

“与”的意思是，参与操作的位中必须全都是 1，那么最终结果才是 1（真），否则就为 0（假）。如果我们将二进制 110101 和 100011 的每一位对齐，进行按位的“与”操作，就会得到 100001。

###### 5、位的“异或”

异或”和“或”有所不同，它具有排异性，也就是说如果参与操作的位相同，那么最终结果就为 0（假），否则为 1（真）。所以，如果要得到 1，参与操作的两个位必须不同，这就是此处“异”的含义。我们将二进制 110101 和 100011 的每一位对齐，进行按位的“异或”操作，可以得到结果是 10110。